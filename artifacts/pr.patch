diff --git a/lan_app/db.py b/lan_app/db.py
index 4776c45..d3753fa 100644
--- a/lan_app/db.py
+++ b/lan_app/db.py
@@ -521,6 +521,50 @@ def set_recording_status_if_current_in(
     return updated.rowcount > 0
 
 
+def set_recording_status_if_current_in_and_no_started_job(
+    recording_id: str,
+    status: str,
+    *,
+    current_statuses: Sequence[str],
+    settings: AppSettings | None = None,
+    quarantine_reason: str | None = None,
+) -> bool:
+    init_db(settings)
+    _validate_recording_status(status)
+    expected_statuses = tuple(dict.fromkeys(str(value) for value in current_statuses))
+    if not expected_statuses:
+        return False
+    for value in expected_statuses:
+        _validate_recording_status(value)
+    placeholders = ", ".join("?" for _ in expected_statuses)
+    now = _utc_now()
+    with connect(settings) as conn:
+        updated = conn.execute(
+            f"""
+            UPDATE recordings
+            SET status = ?, quarantine_reason = ?, updated_at = ?
+            WHERE id = ?
+              AND status IN ({placeholders})
+              AND NOT EXISTS (
+                    SELECT 1
+                    FROM jobs
+                    WHERE jobs.recording_id = recordings.id
+                      AND jobs.status = ?
+              )
+            """,
+            (
+                status,
+                quarantine_reason if status == RECORDING_STATUS_QUARANTINE else None,
+                now,
+                recording_id,
+                *expected_statuses,
+                JOB_STATUS_STARTED,
+            ),
+        )
+        conn.commit()
+    return updated.rowcount > 0
+
+
 def set_recording_project(
     recording_id: str,
     project_id: int | None,
@@ -1888,6 +1932,7 @@ __all__ = [
     "list_recordings",
     "set_recording_status",
     "set_recording_status_if_current_in",
+    "set_recording_status_if_current_in_and_no_started_job",
     "set_recording_project",
     "set_recording_routing_suggestion",
     "set_recording_language_settings",
diff --git a/lan_app/reaper.py b/lan_app/reaper.py
index ac61588..7d182b9 100644
--- a/lan_app/reaper.py
+++ b/lan_app/reaper.py
@@ -15,10 +15,10 @@ from .constants import (
 from .db import (
     fail_job_if_queued,
     fail_job_if_started,
-    has_started_job_for_recording,
     list_processing_recordings_without_started_job,
     list_stale_started_jobs,
     set_recording_status_if_current_in,
+    set_recording_status_if_current_in_and_no_started_job,
 )
 from .jobs import cancel_pending_queue_job
 
@@ -122,10 +122,7 @@ def run_stuck_job_reaper_once(
             # Best-effort dequeue to avoid executing a recovered queued job later.
             cancel_pending_queue_job(active_job_id, settings=cfg)
             recovered_job_ids.append(active_job_id)
-        if has_started_job_for_recording(recording_id, settings=cfg):
-            # Another worker started processing after selection; avoid downgrading it.
-            continue
-        if set_recording_status_if_current_in(
+        if set_recording_status_if_current_in_and_no_started_job(
             recording_id,
             RECORDING_STATUS_NEEDS_REVIEW,
             current_statuses=_ORPHAN_DOWNGRADE_STATUSES,
diff --git a/tests/test_reaper.py b/tests/test_reaper.py
index 90e45f3..bacb0c2 100644
--- a/tests/test_reaper.py
+++ b/tests/test_reaper.py
@@ -552,7 +552,7 @@ def test_reaper_skips_orphan_downgrade_if_status_changes_after_selection(
         "lan_app.reaper.cancel_pending_queue_job",
         lambda *_a, **_k: True,
     )
-    original = db_module.set_recording_status_if_current_in
+    original = db_module.set_recording_status_if_current_in_and_no_started_job
 
     def _racy_set_status(*args, **kwargs):
         set_recording_status(
@@ -562,7 +562,10 @@ def test_reaper_skips_orphan_downgrade_if_status_changes_after_selection(
         )
         return original(*args, **kwargs)
 
-    monkeypatch.setattr("lan_app.reaper.set_recording_status_if_current_in", _racy_set_status)
+    monkeypatch.setattr(
+        "lan_app.reaper.set_recording_status_if_current_in_and_no_started_job",
+        _racy_set_status,
+    )
 
     summary = run_stuck_job_reaper_once(
         settings=cfg,
