diff --git a/lan_app/db.py b/lan_app/db.py
index 201f51e..cca23c7 100644
--- a/lan_app/db.py
+++ b/lan_app/db.py
@@ -1014,6 +1014,33 @@ def requeue_job(
     return updated.rowcount > 0
 
 
+def requeue_job_if_started(
+    job_id: str,
+    *,
+    error: str | None = None,
+    settings: AppSettings | None = None,
+) -> bool:
+    init_db(settings)
+    now = _utc_now()
+    with connect(settings) as conn:
+        updated = conn.execute(
+            """
+            UPDATE jobs
+            SET status = ?, error = ?, started_at = NULL, finished_at = NULL, updated_at = ?
+            WHERE id = ? AND status = ?
+            """,
+            (
+                JOB_STATUS_QUEUED,
+                error,
+                now,
+                job_id,
+                JOB_STATUS_STARTED,
+            ),
+        )
+        conn.commit()
+    return updated.rowcount > 0
+
+
 def finish_job(
     job_id: str,
     *,
@@ -1855,6 +1882,7 @@ __all__ = [
     "create_job_if_no_active_for_recording",
     "start_job",
     "requeue_job",
+    "requeue_job_if_started",
     "finish_job",
     "finish_job_if_started",
     "fail_job",
diff --git a/lan_app/worker_tasks.py b/lan_app/worker_tasks.py
index f80e32f..5f8c5f9 100644
--- a/lan_app/worker_tasks.py
+++ b/lan_app/worker_tasks.py
@@ -40,7 +40,7 @@ from .db import (
     get_recording,
     init_db,
     list_jobs,
-    requeue_job,
+    requeue_job_if_started,
     set_recording_language_settings,
     set_recording_status,
     set_recording_status_if_current_in,
@@ -250,16 +250,18 @@ def _record_retry(
     settings: AppSettings,
     log_path: Path,
     exc: Exception,
-) -> None:
+) -> bool:
     error = str(exc)
     try:
-        requeue_job(
+        requeued = requeue_job_if_started(
             job_id,
             error=f"retryable failure attempt {attempt}/{max_attempts}: {error}",
             settings=settings,
         )
     except Exception:
-        pass
+        return False
+    if not requeued:
+        return False
     try:
         set_recording_status(recording_id, RECORDING_STATUS_QUEUED, settings=settings)
     except Exception:
@@ -275,6 +277,7 @@ def _record_retry(
         )
     except Exception:
         pass
+    return True
 
 
 def _record_failure(
@@ -738,7 +741,7 @@ def process_job(job_id: str, recording_id: str, job_type: str) -> dict[str, str]
                 and attempt < max_attempts
             ):
                 delay_seconds = _retry_delay_seconds(retry_policy, attempt)
-                _record_retry(
+                if _record_retry(
                     job_id=job_id,
                     job_type=job_type,
                     recording_id=recording_id,
@@ -748,10 +751,19 @@ def process_job(job_id: str, recording_id: str, job_type: str) -> dict[str, str]
                     settings=settings,
                     log_path=log_path,
                     exc=exc,
-                )
-                if delay_seconds > 0:
-                    time.sleep(delay_seconds)
-                continue
+                ):
+                    if delay_seconds > 0:
+                        time.sleep(delay_seconds)
+                    continue
+                current_job_status = _job_status(job_id, settings)
+                if current_job_status and current_job_status != JOB_STATUS_STARTED:
+                    _log_stale_inflight_execution(
+                        job_id=job_id,
+                        job_type=job_type,
+                        log_path=log_path,
+                        detail=f"status={current_job_status}",
+                    )
+                    return _ignored_result(job_id, recording_id, job_type)
             _record_failure(
                 job_id=job_id,
                 job_type=job_type,
diff --git a/tests/test_db_queue.py b/tests/test_db_queue.py
index c317adf..5a3cbfc 100644
--- a/tests/test_db_queue.py
+++ b/tests/test_db_queue.py
@@ -10,6 +10,7 @@ from fastapi.testclient import TestClient
 import pytest
 
 from lan_app import api
+from lan_app import db as db_module
 from lan_app import worker_tasks
 from lan_app.config import AppSettings
 from lan_app.constants import (
@@ -858,6 +859,85 @@ def test_worker_retryable_failure_retries_before_marking_failed(
     assert recording["status"] == RECORDING_STATUS_NEEDS_REVIEW
 
 
+def test_worker_retry_does_not_revive_recovered_started_job(
+    tmp_path: Path,
+    monkeypatch,
+):
+    cfg = _test_settings(tmp_path)
+    monkeypatch.setenv("LAN_DATA_ROOT", str(cfg.data_root))
+    monkeypatch.setenv("LAN_RECORDINGS_ROOT", str(cfg.recordings_root))
+    monkeypatch.setenv("LAN_DB_PATH", str(cfg.db_path))
+    monkeypatch.setenv("LAN_PROM_SNAPSHOT_PATH", str(cfg.metrics_snapshot_path))
+
+    init_db(cfg)
+    create_recording(
+        "rec-worker-retry-race-1",
+        source="test",
+        source_filename="retry-race.wav",
+        settings=cfg,
+    )
+    create_job(
+        "job-worker-retry-race-1",
+        recording_id="rec-worker-retry-race-1",
+        job_type=JOB_TYPE_PRECHECK,
+        settings=cfg,
+    )
+
+    raw_audio = cfg.recordings_root / "rec-worker-retry-race-1" / "raw" / "audio.wav"
+    raw_audio.parent.mkdir(parents=True, exist_ok=True)
+    raw_audio.write_bytes(b"\x00")
+    monkeypatch.setattr("lan_app.worker_tasks._resolve_raw_audio_path", lambda *_a, **_k: raw_audio)
+    monkeypatch.setattr(
+        "lan_app.worker_tasks.run_precheck",
+        lambda *_a, **_k: (_ for _ in ()).throw(RuntimeError("retry failure")),
+    )
+
+    def _requeue_after_recovery(job_id: str, *, error: str | None = None, settings=None) -> bool:
+        assert fail_job_if_started(job_id, "stuck job recovered", settings=cfg) is True
+        assert (
+            set_recording_status(
+                "rec-worker-retry-race-1",
+                RECORDING_STATUS_NEEDS_REVIEW,
+                settings=cfg,
+            )
+            is True
+        )
+        return db_module.requeue_job_if_started(
+            job_id,
+            error=error,
+            settings=settings or cfg,
+        )
+
+    monkeypatch.setattr(
+        "lan_app.worker_tasks.requeue_job_if_started",
+        _requeue_after_recovery,
+    )
+    monkeypatch.setattr("lan_app.worker_tasks.time.sleep", lambda _seconds: None)
+
+    result = process_job(
+        "job-worker-retry-race-1",
+        "rec-worker-retry-race-1",
+        JOB_TYPE_PRECHECK,
+    )
+
+    job = get_job("job-worker-retry-race-1", settings=cfg)
+    recording = get_recording("rec-worker-retry-race-1", settings=cfg)
+    assert result["status"] == "ignored"
+    assert job is not None
+    assert recording is not None
+    assert job["status"] == JOB_STATUS_FAILED
+    assert job["error"] == "stuck job recovered"
+    assert recording["status"] == RECORDING_STATUS_NEEDS_REVIEW
+    step_log = (
+        cfg.recordings_root
+        / "rec-worker-retry-race-1"
+        / "logs"
+        / "step-precheck.log"
+    )
+    assert step_log.exists()
+    assert "ignored stale in-flight execution" in step_log.read_text(encoding="utf-8")
+
+
 def test_worker_retry_terminal_uses_effective_max_attempts_cap(
     tmp_path: Path,
     monkeypatch,
