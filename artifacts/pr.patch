diff --git a/lan_app/ui.py b/lan_app/ui.py
index d37a530..5556445 100644
--- a/lan_app/ui.py
+++ b/lan_app/ui.py
@@ -61,6 +61,7 @@ from pyannote.audio import Pipeline  # type: ignore
 from lan_transcriber import llm_client, pipeline
 
 from .api import set_current_result
+from .hf_repo import split_repo_id_and_revision
 from .workers import process_recording
 
 DEVICE = "cuda" if getattr(torch, "cuda", None) and torch.cuda.is_available() else "cpu"
@@ -78,7 +79,14 @@ def transcribe(audio_path: str):
             "â€”",
         )
 
-    diar = Pipeline.from_pretrained("pyannote/speaker-diarization@3.2").to(DEVICE)
+    repo_id, revision = split_repo_id_and_revision("pyannote/speaker-diarization@3.2")
+    kwargs = {"revision": revision} if revision else {}
+    try:
+        diar = Pipeline.from_pretrained(repo_id, **kwargs).to(DEVICE)
+    except TypeError:
+        diar = Pipeline.from_pretrained(
+            f"{repo_id}@{revision}" if revision else repo_id
+        ).to(DEVICE)
     cfg = pipeline.Settings()
     cfg.voices_dir.mkdir(parents=True, exist_ok=True)
     cfg.recordings_root.mkdir(parents=True, exist_ok=True)
diff --git a/lan_app/worker_tasks.py b/lan_app/worker_tasks.py
index a2c9fc7..829ae12 100644
--- a/lan_app/worker_tasks.py
+++ b/lan_app/worker_tasks.py
@@ -49,6 +49,7 @@ from .db import (
     set_recording_status_if_current_in_and_job_started,
     start_job,
 )
+from .hf_repo import split_repo_id_and_revision
 from .routing import refresh_recording_routing
 
 
@@ -462,7 +463,14 @@ def _build_diariser(duration_sec: float | None):
         if missing == "pyannote":
             return _FallbackDiariser(duration_sec)
         raise
-    model = Pipeline.from_pretrained("pyannote/speaker-diarization@3.2")
+    repo_id, revision = split_repo_id_and_revision("pyannote/speaker-diarization@3.2")
+    kwargs = {"revision": revision} if revision else {}
+    try:
+        model = Pipeline.from_pretrained(repo_id, **kwargs)
+    except TypeError:
+        model = Pipeline.from_pretrained(
+            f"{repo_id}@{revision}" if revision else repo_id
+        )
     return _PyannoteDiariser(model)
 
 
@@ -495,7 +503,17 @@ def _run_precheck_pipeline(
     if precheck.quarantine_reason:
         diariser = _FallbackDiariser(precheck.duration_sec)
     else:
-        diariser = _build_diariser(precheck.duration_sec)
+        try:
+            diariser = _build_diariser(precheck.duration_sec)
+        except Exception as exc:
+            _append_step_log(
+                log_path,
+                (
+                    "diariser init failed, falling back: "
+                    f"{type(exc).__name__}: {exc}"
+                ),
+            )
+            diariser = _FallbackDiariser(precheck.duration_sec)
     calendar_title, calendar_attendees = _load_calendar_summary_context(
         recording_id,
         settings,
diff --git a/tasks/QUEUE.md b/tasks/QUEUE.md
index a7f840d..82c8a31 100644
--- a/tasks/QUEUE.md
+++ b/tasks/QUEUE.md
@@ -167,6 +167,6 @@ Queue (in order)
 - Depends on: PR-REMOVE-GDRIVE-01
 
 32) PR-FIX-DIARIZATION-REVISION-01: Fix pyannote diarization revision handling and fallback (avoid failed recordings)
-- Status: TODO
+- Status: DONE
 - Tasks file: tasks/PR-FIX-DIARIZATION-REVISION-01.md
 - Depends on: PR-DOCS-EXPORT-ONLY-01
diff --git a/tests/test_db_queue.py b/tests/test_db_queue.py
index 27056df..88be666 100644
--- a/tests/test_db_queue.py
+++ b/tests/test_db_queue.py
@@ -1593,6 +1593,87 @@ def test_worker_precheck_runs_pipeline_when_safe(tmp_path: Path, monkeypatch):
     assert job["status"] == JOB_STATUS_FINISHED
 
 
+def test_worker_precheck_falls_back_when_diariser_init_fails(tmp_path: Path, monkeypatch):
+    cfg = _test_settings(tmp_path)
+    monkeypatch.setenv("LAN_DATA_ROOT", str(cfg.data_root))
+    monkeypatch.setenv("LAN_RECORDINGS_ROOT", str(cfg.recordings_root))
+    monkeypatch.setenv("LAN_DB_PATH", str(cfg.db_path))
+    monkeypatch.setenv("LAN_PROM_SNAPSHOT_PATH", str(cfg.metrics_snapshot_path))
+
+    init_db(cfg)
+    create_recording(
+        "rec-precheck-fallback-1",
+        source="test",
+        source_filename="fallback.wav",
+        settings=cfg,
+    )
+    create_job(
+        "job-precheck-fallback-1",
+        recording_id="rec-precheck-fallback-1",
+        job_type=JOB_TYPE_PRECHECK,
+        settings=cfg,
+    )
+
+    raw_audio = cfg.recordings_root / "rec-precheck-fallback-1" / "raw" / "audio.wav"
+    raw_audio.parent.mkdir(parents=True, exist_ok=True)
+    raw_audio.write_bytes(b"\x00")
+
+    monkeypatch.setattr("lan_app.worker_tasks._resolve_raw_audio_path", lambda *_a, **_k: raw_audio)
+    monkeypatch.setattr(
+        "lan_app.worker_tasks.run_precheck",
+        lambda *_a, **_k: PrecheckResult(
+            duration_sec=45.0,
+            speech_ratio=0.8,
+            quarantine_reason=None,
+        ),
+    )
+    def _raise_build_error(*_args, **_kwargs):
+        raise RuntimeError("boom")
+
+    monkeypatch.setattr(
+        "lan_app.worker_tasks._build_diariser",
+        _raise_build_error,
+    )
+    monkeypatch.setattr(
+        "lan_app.worker_tasks.refresh_recording_metrics",
+        lambda *_a, **_k: {"participants": [], "meeting": {"total_interruptions": 0}},
+    )
+    monkeypatch.setattr(
+        "lan_app.worker_tasks.refresh_recording_routing",
+        lambda *_a, **_k: {
+            "suggested_project_id": None,
+            "confidence": 0.0,
+            "threshold": 0.5,
+            "auto_selected": False,
+            "status_after_routing": RECORDING_STATUS_READY,
+        },
+    )
+
+    seen_diariser: dict[str, object] = {}
+
+    async def _fake_run_pipeline(*_args, **kwargs):
+        seen_diariser["value"] = kwargs.get("diariser")
+        return None
+
+    monkeypatch.setattr("lan_app.worker_tasks.run_pipeline", _fake_run_pipeline)
+
+    result = process_job(
+        "job-precheck-fallback-1",
+        "rec-precheck-fallback-1",
+        JOB_TYPE_PRECHECK,
+    )
+    assert result["status"] == "ok"
+    assert isinstance(seen_diariser["value"], worker_tasks._FallbackDiariser)
+
+    recording = get_recording("rec-precheck-fallback-1", settings=cfg)
+    assert recording is not None
+    assert recording["status"] == RECORDING_STATUS_READY
+
+    log_path = cfg.recordings_root / "rec-precheck-fallback-1" / "logs" / "step-precheck.log"
+    log_text = log_path.read_text(encoding="utf-8")
+    assert "diariser init failed, falling back: RuntimeError: boom" in log_text
+
+
 def test_worker_clears_progress_when_pipeline_fails(tmp_path: Path, monkeypatch):
     cfg = _test_settings(tmp_path)
     monkeypatch.setenv("LAN_DATA_ROOT", str(cfg.data_root))
@@ -1726,9 +1807,13 @@ def test_build_diariser_wraps_sync_pyannote_pipeline(monkeypatch):
 
     fake_model = _FakeModel()
 
+    from_pretrained_call: dict[str, object] = {}
+
     class _FakePipeline:
         @staticmethod
-        def from_pretrained(_name: str):
+        def from_pretrained(name: str, **kwargs):
+            from_pretrained_call["name"] = name
+            from_pretrained_call["kwargs"] = kwargs
             return fake_model
 
     pyannote_audio = ModuleType("pyannote.audio")
@@ -1743,6 +1828,8 @@ def test_build_diariser_wraps_sync_pyannote_pipeline(monkeypatch):
 
     assert result == {"ok": True}
     assert fake_model.calls == ["/tmp/fake.wav"]
+    assert from_pretrained_call["name"] == "pyannote/speaker-diarization"
+    assert from_pretrained_call["kwargs"] == {"revision": "3.2"}
 
 
 def test_build_diariser_surfaces_pyannote_model_load_errors(monkeypatch):
diff --git a/lan_app/hf_repo.py b/lan_app/hf_repo.py
new file mode 100644
index 0000000..d52f45a
--- /dev/null
+++ b/lan_app/hf_repo.py
@@ -0,0 +1,11 @@
+from __future__ import annotations
+
+
+def split_repo_id_and_revision(value: str) -> tuple[str, str | None]:
+    normalized = value.strip()
+    if "@" not in normalized:
+        return normalized, None
+    repo_id, revision = normalized.split("@", 1)
+    repo_id = repo_id.strip()
+    revision = revision.strip()
+    return repo_id, revision or None
