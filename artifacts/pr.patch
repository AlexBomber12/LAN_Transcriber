diff --git a/lan_app/jobs.py b/lan_app/jobs.py
index d928423..c6652c4 100644
--- a/lan_app/jobs.py
+++ b/lan_app/jobs.py
@@ -13,7 +13,7 @@ from .constants import (
     JOB_STATUS_QUEUED,
     JOB_TYPES,
 )
-from .db import create_job, get_recording, init_db
+from .db import create_job, fail_job, get_recording, init_db
 
 
 class RecordingNotFoundError(ValueError):
@@ -65,13 +65,25 @@ def enqueue_recording_job(
     from .worker_tasks import process_job
 
     queue = get_queue(cfg)
-    queue.enqueue(
-        process_job,
-        job_id,
-        recording_id,
-        job_type,
-        job_id=job_id,
-    )
+    try:
+        queue.enqueue(
+            process_job,
+            job_id,
+            recording_id,
+            job_type,
+            job_id=job_id,
+        )
+    except Exception as exc:
+        # Keep DB queue state terminal when Redis/RQ enqueue fails.
+        try:
+            fail_job(
+                job_id,
+                error=f"queue enqueue failed: {exc}",
+                settings=cfg,
+            )
+        except Exception:
+            pass
+        raise
     return RecordingJob(job_id=job_id, recording_id=recording_id, job_type=job_type)
 
 
diff --git a/lan_app/worker_tasks.py b/lan_app/worker_tasks.py
index f147ec9..dafea7f 100644
--- a/lan_app/worker_tasks.py
+++ b/lan_app/worker_tasks.py
@@ -41,6 +41,30 @@ def _success_status(job_type: str) -> str:
     return RECORDING_STATUS_READY
 
 
+def _record_failure(
+    *,
+    job_id: str,
+    job_type: str,
+    recording_id: str,
+    settings: AppSettings,
+    log_path: Path,
+    exc: Exception,
+) -> None:
+    error = str(exc)
+    try:
+        fail_job(job_id, error, settings=settings)
+    except Exception:
+        pass
+    try:
+        set_recording_status(recording_id, RECORDING_STATUS_FAILED, settings=settings)
+    except Exception:
+        pass
+    try:
+        _append_step_log(log_path, f"failed job={job_id} type={job_type}: {error}")
+    except Exception:
+        pass
+
+
 def process_job(job_id: str, recording_id: str, job_type: str) -> dict[str, str]:
     """
     Execute a queue job.
@@ -55,27 +79,35 @@ def process_job(job_id: str, recording_id: str, job_type: str) -> dict[str, str]
     init_db(settings)
     log_path = _step_log_path(recording_id, job_type, settings)
 
-    if not start_job(job_id, settings=settings):
-        raise ValueError(f"Job not found: {job_id}")
-    set_recording_status(
-        recording_id,
-        RECORDING_STATUS_PROCESSING,
-        settings=settings,
-    )
-    _append_step_log(log_path, f"started job={job_id} type={job_type}")
-
     try:
+        if not start_job(job_id, settings=settings):
+            raise ValueError(f"Job not found: {job_id}")
+        if not set_recording_status(
+            recording_id,
+            RECORDING_STATUS_PROCESSING,
+            settings=settings,
+        ):
+            raise ValueError(f"Recording not found: {recording_id}")
+        _append_step_log(log_path, f"started job={job_id} type={job_type}")
+
         final_status = _success_status(job_type)
-        set_recording_status(recording_id, final_status, settings=settings)
-        finish_job(job_id, settings=settings)
+        if not set_recording_status(recording_id, final_status, settings=settings):
+            raise ValueError(f"Recording not found: {recording_id}")
+        if not finish_job(job_id, settings=settings):
+            raise ValueError(f"Job not found: {job_id}")
         _append_step_log(
             log_path,
             f"finished job={job_id} type={job_type} recording_status={final_status}",
         )
     except Exception as exc:
-        fail_job(job_id, str(exc), settings=settings)
-        set_recording_status(recording_id, RECORDING_STATUS_FAILED, settings=settings)
-        _append_step_log(log_path, f"failed job={job_id} type={job_type}: {exc}")
+        _record_failure(
+            job_id=job_id,
+            job_type=job_type,
+            recording_id=recording_id,
+            settings=settings,
+            log_path=log_path,
+            exc=exc,
+        )
         raise
 
     return {
diff --git a/tests/test_db_queue.py b/tests/test_db_queue.py
index ede652e..9d1fdb6 100644
--- a/tests/test_db_queue.py
+++ b/tests/test_db_queue.py
@@ -3,12 +3,15 @@ from __future__ import annotations
 from pathlib import Path
 
 from fastapi.testclient import TestClient
+import pytest
 
 from lan_app import api
 from lan_app.config import AppSettings
 from lan_app.constants import (
+    JOB_STATUS_FAILED,
     JOB_STATUS_FINISHED,
     JOB_TYPE_PRECHECK,
+    RECORDING_STATUS_FAILED,
     RECORDING_STATUS_QUARANTINE,
     RECORDING_STATUS_READY,
 )
@@ -19,8 +22,9 @@ from lan_app.db import (
     get_job,
     get_recording,
     init_db,
+    list_jobs,
 )
-from lan_app.jobs import RecordingJob
+from lan_app.jobs import RecordingJob, enqueue_recording_job
 from lan_app.worker_tasks import process_job
 
 
@@ -161,3 +165,71 @@ def test_recordings_and_jobs_api_actions(tmp_path: Path, monkeypatch):
 
     missing = client.get("/api/recordings/rec-api-1")
     assert missing.status_code == 404
+
+
+def test_enqueue_marks_job_failed_when_redis_enqueue_fails(tmp_path: Path, monkeypatch):
+    cfg = _test_settings(tmp_path)
+    init_db(cfg)
+    create_recording(
+        "rec-enqueue-fail-1",
+        source="test",
+        source_filename="enqueue.mp3",
+        settings=cfg,
+    )
+
+    class _BrokenQueue:
+        def enqueue(self, *_args, **_kwargs):
+            raise RuntimeError("redis down")
+
+    monkeypatch.setattr("lan_app.jobs.get_queue", lambda _cfg: _BrokenQueue())
+
+    with pytest.raises(RuntimeError) as exc_info:
+        enqueue_recording_job(
+            "rec-enqueue-fail-1",
+            job_type=JOB_TYPE_PRECHECK,
+            settings=cfg,
+        )
+    assert "redis down" in str(exc_info.value)
+
+    jobs, total = list_jobs(settings=cfg, recording_id="rec-enqueue-fail-1")
+    assert total == 1
+    assert jobs[0]["status"] == JOB_STATUS_FAILED
+    assert "queue enqueue failed" in jobs[0]["error"]
+
+
+def test_worker_setup_failure_marks_job_and_recording_failed(tmp_path: Path, monkeypatch):
+    cfg = _test_settings(tmp_path)
+    monkeypatch.setenv("LAN_DATA_ROOT", str(cfg.data_root))
+    monkeypatch.setenv("LAN_RECORDINGS_ROOT", str(cfg.recordings_root))
+    monkeypatch.setenv("LAN_DB_PATH", str(cfg.db_path))
+    monkeypatch.setenv("LAN_PROM_SNAPSHOT_PATH", str(cfg.metrics_snapshot_path))
+
+    init_db(cfg)
+    create_recording(
+        "rec-worker-fail-1",
+        source="test",
+        source_filename="setup-fail.mp3",
+        settings=cfg,
+    )
+    create_job(
+        "job-worker-fail-1",
+        recording_id="rec-worker-fail-1",
+        job_type=JOB_TYPE_PRECHECK,
+        settings=cfg,
+    )
+
+    def _boom(*_args, **_kwargs):
+        raise OSError("disk full")
+
+    monkeypatch.setattr("lan_app.worker_tasks._append_step_log", _boom)
+
+    with pytest.raises(OSError) as exc_info:
+        process_job("job-worker-fail-1", "rec-worker-fail-1", JOB_TYPE_PRECHECK)
+    assert "disk full" in str(exc_info.value)
+
+    job = get_job("job-worker-fail-1", settings=cfg)
+    recording = get_recording("rec-worker-fail-1", settings=cfg)
+    assert job is not None
+    assert recording is not None
+    assert job["status"] == JOB_STATUS_FAILED
+    assert recording["status"] == RECORDING_STATUS_FAILED
