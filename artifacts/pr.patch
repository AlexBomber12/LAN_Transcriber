diff --git a/.env.example b/.env.example
index e3659c0..01f4c11 100644
--- a/.env.example
+++ b/.env.example
@@ -33,6 +33,7 @@ MS_CLIENT_ID=
 MS_SCOPES=offline_access User.Read Notes.ReadWrite Calendars.Read
 CALENDAR_MATCH_WINDOW_MINUTES=45
 CALENDAR_AUTO_MATCH_THRESHOLD=0.6
+ROUTING_AUTO_SELECT_THRESHOLD=0.65
 
 # Plaud fetcher (beta)
 FETCH_INTERVAL_SEC=300
diff --git a/lan_app/config.py b/lan_app/config.py
index 9e5f483..29dc89f 100644
--- a/lan_app/config.py
+++ b/lan_app/config.py
@@ -97,6 +97,15 @@ class AppSettings(BaseSettings):
             "LAN_CALENDAR_AUTO_MATCH_THRESHOLD",
         ),
     )
+    routing_auto_select_threshold: float = Field(
+        default=0.65,
+        ge=0.0,
+        le=1.0,
+        validation_alias=AliasChoices(
+            "ROUTING_AUTO_SELECT_THRESHOLD",
+            "LAN_ROUTING_AUTO_SELECT_THRESHOLD",
+        ),
+    )
 
     @property
     def ms_scopes_list(self) -> list[str]:
diff --git a/lan_app/db.py b/lan_app/db.py
index 4968ae1..6d052d0 100644
--- a/lan_app/db.py
+++ b/lan_app/db.py
@@ -177,10 +177,62 @@ _MIGRATIONS: tuple[str, ...] = (
     """
     ALTER TABLE recordings ADD COLUMN onenote_page_url TEXT;
     """,
+    """
+    ALTER TABLE recordings ADD COLUMN suggested_project_id INTEGER;
+    """,
+    """
+    ALTER TABLE recordings ADD COLUMN routing_confidence REAL;
+    """,
+    """
+    ALTER TABLE recordings ADD COLUMN routing_rationale_json TEXT NOT NULL DEFAULT '[]';
+    """,
+    """
+    CREATE INDEX IF NOT EXISTS idx_recordings_suggested_project_id
+        ON recordings(suggested_project_id);
+
+    CREATE TABLE IF NOT EXISTS routing_training_examples (
+        id INTEGER PRIMARY KEY AUTOINCREMENT,
+        recording_id TEXT NOT NULL,
+        project_id INTEGER NOT NULL,
+        calendar_subject_tokens_json TEXT NOT NULL DEFAULT '[]',
+        tags_json TEXT NOT NULL DEFAULT '[]',
+        voice_profile_ids_json TEXT NOT NULL DEFAULT '[]',
+        created_at TEXT NOT NULL,
+        FOREIGN KEY(recording_id) REFERENCES recordings(id) ON DELETE CASCADE,
+        FOREIGN KEY(project_id) REFERENCES projects(id) ON DELETE CASCADE
+    );
+
+    CREATE INDEX IF NOT EXISTS idx_routing_training_examples_project_id
+        ON routing_training_examples(project_id);
+    CREATE INDEX IF NOT EXISTS idx_routing_training_examples_recording_id
+        ON routing_training_examples(recording_id);
+
+    CREATE TABLE IF NOT EXISTS routing_project_keyword_weights (
+        project_id INTEGER NOT NULL,
+        keyword TEXT NOT NULL,
+        weight REAL NOT NULL,
+        updated_at TEXT NOT NULL,
+        PRIMARY KEY(project_id, keyword),
+        FOREIGN KEY(project_id) REFERENCES projects(id) ON DELETE CASCADE
+    );
+
+    CREATE INDEX IF NOT EXISTS idx_routing_project_keyword_weights_project_id
+        ON routing_project_keyword_weights(project_id);
+    """,
 )
 
 _UNSET = object()
 
+_RECORDING_SELECT_SQL = """
+SELECT
+    r.*,
+    p.name AS project_name,
+    sp.name AS suggested_project_name
+FROM recordings AS r
+LEFT JOIN projects AS p ON p.id = r.project_id
+LEFT JOIN projects AS sp ON sp.id = r.suggested_project_id
+"""
+
 
 def _utc_now() -> str:
     return datetime.now(tz=timezone.utc).replace(microsecond=0).isoformat().replace(
@@ -218,6 +270,10 @@ def _validate_job_type(job_type: str) -> None:
         raise ValueError(f"Unsupported job type: {job_type}")
 
 
+def _normalise_keyword(value: object) -> str:
+    return " ".join(str(value).strip().lower().split())
+
+
 def db_path(settings: AppSettings | None = None) -> Path:
     cfg = settings or AppSettings()
     return cfg.db_path
@@ -298,7 +354,7 @@ def create_recording(
             ),
         )
         row = conn.execute(
-            "SELECT * FROM recordings WHERE id = ?",
+            f"{_RECORDING_SELECT_SQL} WHERE r.id = ?",
             (recording_id,),
         ).fetchone()
         conn.commit()
@@ -313,7 +369,7 @@ def get_recording(
     init_db(settings)
     with connect(settings) as conn:
         row = conn.execute(
-            "SELECT * FROM recordings WHERE id = ?",
+            f"{_RECORDING_SELECT_SQL} WHERE r.id = ?",
             (recording_id,),
         ).fetchone()
     return _as_dict(row)
@@ -331,7 +387,7 @@ def list_recordings(
     params: list[Any] = []
     if status is not None:
         _validate_recording_status(status)
-        filters.append("status = ?")
+        filters.append("r.status = ?")
         params.append(status)
 
     where_sql = f"WHERE {' AND '.join(filters)}" if filters else ""
@@ -341,16 +397,15 @@ def list_recordings(
     with connect(settings) as conn:
         total = int(
             conn.execute(
-                f"SELECT COUNT(*) FROM recordings {where_sql}",
+                f"SELECT COUNT(*) FROM recordings AS r {where_sql}",
                 params,
             ).fetchone()[0]
         )
         rows = conn.execute(
             f"""
-            SELECT *
-            FROM recordings
+            {_RECORDING_SELECT_SQL}
             {where_sql}
-            ORDER BY created_at DESC
+            ORDER BY r.created_at DESC
             LIMIT ? OFFSET ?
             """,
             [*params, safe_limit, safe_offset],
@@ -386,6 +441,66 @@ def set_recording_status(
     return updated.rowcount > 0
 
 
+def set_recording_project(
+    recording_id: str,
+    project_id: int | None,
+    *,
+    settings: AppSettings | None = None,
+) -> bool:
+    init_db(settings)
+    now = _utc_now()
+    resolved_project_id = None if project_id is None else int(project_id)
+    with connect(settings) as conn:
+        updated = conn.execute(
+            """
+            UPDATE recordings
+            SET project_id = ?, updated_at = ?
+            WHERE id = ?
+            """,
+            (resolved_project_id, now, recording_id),
+        )
+        conn.commit()
+    return updated.rowcount > 0
+
+
+def set_recording_routing_suggestion(
+    recording_id: str,
+    *,
+    suggested_project_id: int | None,
+    routing_confidence: float | None,
+    routing_rationale: list[str] | None,
+    settings: AppSettings | None = None,
+) -> bool:
+    init_db(settings)
+    now = _utc_now()
+    resolved_project_id = (
+        None if suggested_project_id is None else int(suggested_project_id)
+    )
+    if routing_confidence is None:
+        confidence_value = None
+    else:
+        confidence_value = max(0.0, min(float(routing_confidence), 1.0))
+    rationale_rows = [str(item).strip() for item in (routing_rationale or [])]
+    rationale = [item for item in rationale_rows if item]
+    with connect(settings) as conn:
+        updated = conn.execute(
+            """
+            UPDATE recordings
+            SET suggested_project_id = ?, routing_confidence = ?, routing_rationale_json = ?, updated_at = ?
+            WHERE id = ?
+            """,
+            (
+                resolved_project_id,
+                confidence_value,
+                json.dumps(rationale, ensure_ascii=True),
+                now,
+                recording_id,
+            ),
+        )
+        conn.commit()
+    return updated.rowcount > 0
+
+
 def set_recording_language_settings(
     recording_id: str,
     *,
@@ -708,6 +823,139 @@ def delete_project(
     return deleted.rowcount > 0
 
 
+def create_routing_training_example(
+    *,
+    recording_id: str,
+    project_id: int,
+    calendar_subject_tokens: list[str],
+    tags: list[str],
+    voice_profile_ids: list[int],
+    settings: AppSettings | None = None,
+) -> dict[str, Any]:
+    init_db(settings)
+    now = _utc_now()
+    normalized_calendar = sorted(
+        {_normalise_keyword(token) for token in calendar_subject_tokens if _normalise_keyword(token)}
+    )
+    normalized_tags = sorted({_normalise_keyword(token) for token in tags if _normalise_keyword(token)})
+    normalized_voice_ids = sorted({int(value) for value in voice_profile_ids})
+    with connect(settings) as conn:
+        cursor = conn.execute(
+            """
+            INSERT INTO routing_training_examples (
+                recording_id,
+                project_id,
+                calendar_subject_tokens_json,
+                tags_json,
+                voice_profile_ids_json,
+                created_at
+            )
+            VALUES (?, ?, ?, ?, ?, ?)
+            """,
+            (
+                recording_id,
+                int(project_id),
+                json.dumps(normalized_calendar, ensure_ascii=True),
+                json.dumps(normalized_tags, ensure_ascii=True),
+                json.dumps(normalized_voice_ids, ensure_ascii=True),
+                now,
+            ),
+        )
+        row = conn.execute(
+            "SELECT * FROM routing_training_examples WHERE id = ?",
+            (cursor.lastrowid,),
+        ).fetchone()
+        conn.commit()
+    return _as_dict(row) or {}
+
+
+def count_routing_training_examples(
+    *,
+    project_id: int | None = None,
+    settings: AppSettings | None = None,
+) -> int:
+    init_db(settings)
+    clauses: list[str] = []
+    params: list[Any] = []
+    if project_id is not None:
+        clauses.append("project_id = ?")
+        params.append(int(project_id))
+    where_sql = f"WHERE {' AND '.join(clauses)}" if clauses else ""
+    with connect(settings) as conn:
+        row = conn.execute(
+            f"SELECT COUNT(*) FROM routing_training_examples {where_sql}",
+            tuple(params),
+        ).fetchone()
+    return int(row[0]) if row is not None else 0
+
+
+def increment_project_keyword_weights(
+    *,
+    project_id: int,
+    keyword_deltas: dict[str, float],
+    settings: AppSettings | None = None,
+) -> int:
+    init_db(settings)
+    now = _utc_now()
+    updates = 0
+    with connect(settings) as conn:
+        for raw_keyword, raw_delta in keyword_deltas.items():
+            keyword = _normalise_keyword(raw_keyword)
+            if not keyword:
+                continue
+            delta = float(raw_delta)
+            if delta == 0.0:
+                continue
+            conn.execute(
+                """
+                INSERT INTO routing_project_keyword_weights (
+                    project_id,
+                    keyword,
+                    weight,
+                    updated_at
+                )
+                VALUES (?, ?, ?, ?)
+                ON CONFLICT(project_id, keyword) DO UPDATE SET
+                    weight = routing_project_keyword_weights.weight + excluded.weight,
+                    updated_at = excluded.updated_at
+                """,
+                (
+                    int(project_id),
+                    keyword,
+                    delta,
+                    now,
+                ),
+            )
+            updates += 1
+        conn.commit()
+    return updates
+
+
+def list_project_keyword_weights(
+    *,
+    project_id: int | None = None,
+    settings: AppSettings | None = None,
+) -> list[dict[str, Any]]:
+    init_db(settings)
+    clauses: list[str] = []
+    params: list[Any] = []
+    if project_id is not None:
+        clauses.append("project_id = ?")
+        params.append(int(project_id))
+    where_sql = f"WHERE {' AND '.join(clauses)}" if clauses else ""
+    with connect(settings) as conn:
+        rows = conn.execute(
+            f"""
+            SELECT *
+            FROM routing_project_keyword_weights
+            {where_sql}
+            ORDER BY project_id, keyword
+            """,
+            tuple(params),
+        ).fetchall()
+    return [_as_dict(row) or {} for row in rows]
+
+
 def list_voice_profiles(
     *,
     settings: AppSettings | None = None,
@@ -1190,6 +1438,8 @@ __all__ = [
     "get_recording",
     "list_recordings",
     "set_recording_status",
+    "set_recording_project",
+    "set_recording_routing_suggestion",
     "set_recording_language_settings",
     "set_recording_publish_result",
     "delete_recording",
@@ -1204,6 +1454,10 @@ __all__ = [
     "create_project",
     "update_project_onenote_mapping",
     "delete_project",
+    "create_routing_training_example",
+    "count_routing_training_examples",
+    "increment_project_keyword_weights",
+    "list_project_keyword_weights",
     "list_voice_profiles",
     "create_voice_profile",
     "delete_voice_profile",
diff --git a/lan_app/templates/recording_detail.html b/lan_app/templates/recording_detail.html
index be788ad..5358aa9 100644
--- a/lan_app/templates/recording_detail.html
+++ b/lan_app/templates/recording_detail.html
@@ -33,7 +33,16 @@
     <span class="k">Status</span><span class="v"><span class="badge s-{{ rec.status }}">{{ rec.status }}</span></span>
     <span class="k">Captured at</span><span class="v">{{ rec.captured_at[:19].replace('T',' ') if rec.captured_at else '—' }}</span>
     <span class="k">Duration</span><span class="v">{% if rec.duration_sec %}{{ rec.duration_sec }}s{% else %}—{% endif %}</span>
-    <span class="k">Project ID</span><span class="v">{{ rec.project_id or '—' }}</span>
+    <span class="k">Project</span><span class="v">{{ rec.project_name or (rec.project_id and ('#' ~ rec.project_id)) or '—' }}</span>
+    <span class="k">Suggested project</span><span class="v">{{ rec.suggested_project_name or (rec.suggested_project_id and ('#' ~ rec.suggested_project_id)) or '—' }}</span>
+    <span class="k">Routing confidence</span>
+    <span class="v">
+      {% if rec.routing_confidence is not none %}
+      {{ '%.2f'|format(rec.routing_confidence) }}
+      {% else %}
+      —
+      {% endif %}
+    </span>
     <span class="k">Language (auto)</span><span class="v">{{ rec.language_auto or '—' }}</span>
     <span class="k">Transcript language override</span><span class="v">{{ rec.language_override or '—' }}</span>
     <span class="k">Target summary language</span><span class="v">{{ rec.target_summary_language or '—' }}</span>
@@ -172,7 +181,55 @@
   </form>
 
 {% elif current_tab == 'project' %}
-  <p class="placeholder">Project assignment — available after PR-CALENDAR-01.</p>
+  {% set prj = project or {} %}
+  {% set project_items = prj.projects or [] %}
+
+  <h2>Project Assignment</h2>
+  <div class="info-grid">
+    <span class="k">Current project</span><span class="v">{{ prj.selected_project_name or (prj.selected_project_id and ('#' ~ prj.selected_project_id)) or 'Unassigned' }}</span>
+    <span class="k">Suggested project</span><span class="v">{{ prj.suggested_project_name or (prj.suggested_project_id and ('#' ~ prj.suggested_project_id)) or '—' }}</span>
+    <span class="k">Confidence</span><span class="v">{{ '%.2f'|format(prj.confidence or 0.0) }}</span>
+    <span class="k">Auto-select threshold</span><span class="v">{{ '%.2f'|format(prj.threshold or 0.0) }}</span>
+    <span class="k">Training examples (total)</span><span class="v">{{ prj.training_examples_total or 0 }}</span>
+    <span class="k">Training examples (this project)</span><span class="v">{{ prj.training_examples_selected_project or 0 }}</span>
+  </div>
+
+  {% if (prj.confidence or 0.0) < (prj.threshold or 0.0) %}
+  <p style="margin-top:8px;color:#92400e">
+    Confidence is below threshold; this recording should remain in manual review.
+  </p>
+  {% endif %}
+
+  <form method="post" action="/ui/recordings/{{ rec.id }}/project" style="margin-top:10px">
+    <div class="form-row">
+      <label for="project_id">Project</label>
+      <select id="project_id" name="project_id" style="width:280px">
+        <option value="">Unassigned</option>
+        {% for p in project_items %}
+        <option value="{{ p.id }}" {% if prj.selected_project_id == p.id %}selected{% endif %}>{{ p.name }}</option>
+        {% endfor %}
+      </select>
+    </div>
+    <div class="form-row">
+      <label for="train_routing">Train routing</label>
+      <input id="train_routing" type="checkbox" name="train_routing" value="1" checked>
+      <span style="font-size:12px;color:#555">Store this manual choice as a routing training example.</span>
+    </div>
+    <div class="filters" style="margin-top:8px">
+      <button type="submit" class="btn">Save project</button>
+    </div>
+  </form>
+
+  <h2>Routing Rationale</h2>
+  {% if prj.rationale %}
+  <ul>
+    {% for reason in prj.rationale %}
+    <li>{{ reason }}</li>
+    {% endfor %}
+  </ul>
+  {% else %}
+  <p class="placeholder">No routing rationale available yet.</p>
+  {% endif %}
 
 {% elif current_tab == 'speakers' %}
   {% set sp = speakers or {} %}
diff --git a/lan_app/templates/recordings.html b/lan_app/templates/recordings.html
index 4387e32..3a48fa4 100644
--- a/lan_app/templates/recordings.html
+++ b/lan_app/templates/recordings.html
@@ -28,6 +28,8 @@
       <th>ID</th>
       <th>Filename</th>
       <th>Status</th>
+      <th>Suggested Project</th>
+      <th>Confidence</th>
       <th>Captured</th>
       <th>Duration</th>
       <th>Source</th>
@@ -40,6 +42,22 @@
       <td title="{{ r.id }}"><a href="/recordings/{{ r.id }}" style="text-decoration:none;color:#1d4ed8">{{ r.id[:16] }}…</a></td>
       <td title="{{ r.source_filename }}">{{ r.source_filename }}</td>
       <td><span class="badge s-{{ r.status }}">{{ r.status }}</span></td>
+      <td>
+        {% if r.suggested_project_name %}
+        {{ r.suggested_project_name }}
+        {% elif r.suggested_project_id %}
+        #{{ r.suggested_project_id }}
+        {% else %}
+        —
+        {% endif %}
+      </td>
+      <td>
+        {% if r.routing_confidence is not none %}
+        {{ '%.2f'|format(r.routing_confidence) }}
+        {% else %}
+        —
+        {% endif %}
+      </td>
       <td>{{ r.captured_at[:19].replace('T',' ') if r.captured_at else '—' }}</td>
       <td>{% if r.duration_sec %}{{ r.duration_sec }}s{% else %}—{% endif %}</td>
       <td>{{ r.source }}</td>
diff --git a/lan_app/ui_routes.py b/lan_app/ui_routes.py
index 893ad62..12c049c 100644
--- a/lan_app/ui_routes.py
+++ b/lan_app/ui_routes.py
@@ -32,6 +32,7 @@ from .constants import (
     RECORDING_STATUS_QUARANTINE,
 )
 from .db import (
+    count_routing_training_examples,
     create_voice_sample,
     create_project,
     create_voice_profile,
@@ -48,6 +49,7 @@ from .db import (
     list_voice_samples,
     list_voice_profiles,
     update_project_onenote_mapping,
+    set_recording_project,
     set_speaker_assignment,
     set_recording_language_settings,
     set_recording_status,
@@ -60,6 +62,7 @@ from .onenote import (
     list_onenote_sections,
     publish_recording_to_onenote,
 )
+from .routing import refresh_recording_routing, train_routing_from_manual_selection
 from lan_transcriber.artifacts import atomic_write_json
 from lan_transcriber.llm_client import LLMClient
 from lan_transcriber.pipeline import Settings as PipelineSettings
@@ -610,6 +613,67 @@ def _speakers_tab_context(recording_id: str, settings: AppSettings) -> dict[str,
     }
 
 
+def _as_int(value: Any) -> int | None:
+    try:
+        if value is None:
+            return None
+        return int(value)
+    except (TypeError, ValueError):
+        return None
+
+
+def _project_tab_context(recording_id: str, rec: dict[str, Any], settings: AppSettings) -> dict[str, Any]:
+    decision = refresh_recording_routing(
+        recording_id,
+        settings=settings,
+        apply_workflow=False,
+    )
+    refreshed = get_recording(recording_id, settings=settings) or rec
+    projects = list_projects(settings=settings)
+    selected_project_id = _as_int(refreshed.get("project_id"))
+    selected_project = None
+    for project in projects:
+        if _as_int(project.get("id")) == selected_project_id:
+            selected_project = project
+            break
+
+    suggested_project_id = _as_int(decision.get("suggested_project_id"))
+    if suggested_project_id is None:
+        suggested_project_id = _as_int(refreshed.get("suggested_project_id"))
+    suggested_project_name = str(decision.get("suggested_project_name") or "").strip()
+    if not suggested_project_name:
+        suggested_project_name = str(refreshed.get("suggested_project_name") or "").strip()
+    confidence_raw = decision.get("confidence", refreshed.get("routing_confidence"))
+    try:
+        confidence = max(0.0, min(float(confidence_raw), 1.0))
+    except (TypeError, ValueError):
+        confidence = 0.0
+    threshold = float(decision.get("threshold") or settings.routing_auto_select_threshold)
+
+    rationale_payload = decision.get("rationale")
+    if not isinstance(rationale_payload, list):
+        rationale_payload = refreshed.get("routing_rationale_json")
+    rationale = [str(item).strip() for item in (rationale_payload or []) if str(item).strip()]
+
+    selected_training_examples = (
+        count_routing_training_examples(project_id=selected_project_id, settings=settings)
+        if selected_project_id is not None
+        else 0
+    )
+    return {
+        "projects": projects,
+        "selected_project_id": selected_project_id,
+        "selected_project_name": str((selected_project or {}).get("name") or "").strip(),
+        "suggested_project_id": suggested_project_id,
+        "suggested_project_name": suggested_project_name,
+        "confidence": confidence,
+        "threshold": threshold,
+        "rationale": rationale,
+        "training_examples_total": count_routing_training_examples(settings=settings),
+        "training_examples_selected_project": selected_training_examples,
+    }
+
+
 def _sync_transcript_language_settings(
     recording_id: str,
     *,
@@ -921,6 +985,7 @@ async def ui_recording_detail(
     summary: dict[str, Any] | None = None
     metrics: dict[str, Any] | None = None
     speakers: dict[str, Any] | None = None
+    project: dict[str, Any] | None = None
     if current_tab == "calendar":
         try:
             calendar = await run_in_threadpool(
@@ -939,6 +1004,9 @@ async def ui_recording_detail(
         language = _language_tab_context(recording_id, rec, _settings)
     if current_tab == "speakers":
         speakers = _speakers_tab_context(recording_id, _settings)
+    if current_tab == "project":
+        project = _project_tab_context(recording_id, rec, _settings)
+        rec = get_recording(recording_id, settings=_settings) or rec
     if current_tab in {"overview", "metrics"}:
         summary = _summary_context(recording_id, _settings)
     if current_tab == "metrics":
@@ -958,6 +1026,7 @@ async def ui_recording_detail(
             "summary": summary,
             "metrics": metrics,
             "speakers": speakers,
+            "project": project,
             "onenote_page_url": onenote_page_url,
         },
     )
@@ -1096,6 +1165,52 @@ async def ui_add_speaker_sample(
     return RedirectResponse(f"/recordings/{recording_id}?tab=speakers", status_code=303)
 
 
+@ui_router.post("/ui/recordings/{recording_id}/project")
+async def ui_set_recording_project(
+    recording_id: str,
+    project_id: str = Form(default=""),
+    train_routing: str = Form(default=""),
+) -> Any:
+    if get_recording(recording_id, settings=_settings) is None:
+        return HTMLResponse("Not found", status_code=404)
+
+    token = project_id.strip()
+    resolved_project_id: int | None = None
+    if token:
+        try:
+            resolved_project_id = int(token)
+        except ValueError:
+            return HTMLResponse("project_id must be an integer", status_code=422)
+
+    try:
+        updated = set_recording_project(
+            recording_id,
+            resolved_project_id,
+            settings=_settings,
+        )
+    except sqlite3.IntegrityError:
+        return HTMLResponse("Project not found", status_code=404)
+    if not updated:
+        return HTMLResponse("Not found", status_code=404)
+
+    should_train = train_routing.strip().lower() in {"1", "true", "on", "yes"}
+    if should_train and resolved_project_id is not None:
+        try:
+            train_routing_from_manual_selection(
+                recording_id,
+                resolved_project_id,
+                settings=_settings,
+            )
+        except KeyError:
+            return HTMLResponse("Project not found", status_code=404)
+    refresh_recording_routing(
+        recording_id,
+        settings=_settings,
+        apply_workflow=False,
+    )
+    return RedirectResponse(f"/recordings/{recording_id}?tab=project", status_code=303)
+
+
 # ---------------------------------------------------------------------------
 # Projects
 # ---------------------------------------------------------------------------
diff --git a/lan_app/worker_tasks.py b/lan_app/worker_tasks.py
index 73111fb..dd77683 100644
--- a/lan_app/worker_tasks.py
+++ b/lan_app/worker_tasks.py
@@ -19,6 +19,7 @@ from .constants import (
     JOB_TYPE_PUBLISH,
     JOB_TYPES,
     RECORDING_STATUS_FAILED,
+    RECORDING_STATUS_NEEDS_REVIEW,
     RECORDING_STATUS_PROCESSING,
     RECORDING_STATUS_PUBLISHED,
     RECORDING_STATUS_QUARANTINE,
@@ -34,6 +35,7 @@ from .db import (
     set_recording_status,
     start_job,
 )
+from .routing import refresh_recording_routing
 
 
 def _utc_now() -> str:
@@ -293,6 +295,24 @@ def _run_precheck_pipeline(
             f"quarantined reason={precheck.quarantine_reason}",
         )
         return RECORDING_STATUS_QUARANTINE, precheck.quarantine_reason
+    routing = refresh_recording_routing(
+        recording_id,
+        settings=settings,
+        apply_workflow=True,
+    )
+    _append_step_log(
+        log_path,
+        (
+            "routing "
+            f"suggested_project_id={routing.get('suggested_project_id')} "
+            f"confidence={float(routing.get('confidence') or 0.0):.2f} "
+            f"threshold={float(routing.get('threshold') or 0.0):.2f} "
+            f"auto_selected={bool(routing.get('auto_selected'))} "
+            f"status_after={routing.get('status_after_routing')}"
+        ),
+    )
+    if routing.get("status_after_routing") == RECORDING_STATUS_NEEDS_REVIEW:
+        return RECORDING_STATUS_NEEDS_REVIEW, None
     return RECORDING_STATUS_READY, None
 
 
diff --git a/tasks/QUEUE.md b/tasks/QUEUE.md
index 0927f44..ea16dfc 100644
--- a/tasks/QUEUE.md
+++ b/tasks/QUEUE.md
@@ -77,7 +77,7 @@ Queue (in order)
 - Depends on: PR-MS-AUTH-01 and PR-LLM-01 and PR-METRICS-01
 
 14) PR-ROUTING-01: Project suggestion (calendar + voices + text) with confidence + NeedsReview workflow
-- Status: TODO
+- Status: DONE
 - Tasks file: tasks/PR-ROUTING-01.md
 - Depends on: PR-CALENDAR-01 and PR-VOICE-01 and PR-ONENOTE-01
 
diff --git a/tests/test_app_config.py b/tests/test_app_config.py
index 74f15f1..29a3fc2 100644
--- a/tests/test_app_config.py
+++ b/tests/test_app_config.py
@@ -58,3 +58,10 @@ def test_calendar_match_settings_from_env(monkeypatch):
     cfg = AppSettings()
     assert cfg.calendar_match_window_minutes == 30
     assert cfg.calendar_auto_match_threshold == 0.7
+
+
+def test_routing_threshold_from_env(monkeypatch):
+    monkeypatch.setenv("ROUTING_AUTO_SELECT_THRESHOLD", "0.73")
+
+    cfg = AppSettings()
+    assert cfg.routing_auto_select_threshold == 0.73
diff --git a/tests/test_db_queue.py b/tests/test_db_queue.py
index 50fd239..41fa9cc 100644
--- a/tests/test_db_queue.py
+++ b/tests/test_db_queue.py
@@ -68,6 +68,8 @@ def test_init_db_creates_mvp_tables(tmp_path: Path):
         "calendar_matches",
         "meeting_metrics",
         "participant_metrics",
+        "routing_training_examples",
+        "routing_project_keyword_weights",
     }
     assert expected.issubset(names)
 
diff --git a/tests/test_ui_routes.py b/tests/test_ui_routes.py
index 0e46780..6adba3e 100644
--- a/tests/test_ui_routes.py
+++ b/tests/test_ui_routes.py
@@ -11,6 +11,7 @@ from fastapi.testclient import TestClient
 from lan_app import api, ui_routes
 from lan_app.config import AppSettings
 from lan_app.db import (
+    count_routing_training_examples,
     create_voice_sample,
     create_job,
     create_recording,
@@ -21,13 +22,16 @@ from lan_app.db import (
     list_voice_samples,
     init_db,
     list_projects,
+    list_project_keyword_weights,
     replace_participant_metrics,
     list_voice_profiles,
     set_speaker_assignment,
+    upsert_calendar_match,
     upsert_meeting_metrics,
 )
 from lan_app.constants import (
     JOB_TYPE_PRECHECK,
+    RECORDING_STATUS_NEEDS_REVIEW,
     RECORDING_STATUS_READY,
 )
 
@@ -181,10 +185,86 @@ def test_recording_detail_calendar_tab(seeded_client):
     assert "Save selection" in r.text
 
 
-def test_recording_detail_placeholder_tabs(seeded_client):
+def test_recording_detail_project_tab(seeded_client):
     r = seeded_client.get("/recordings/rec-ui-1?tab=project")
     assert r.status_code == 200
-    assert "placeholder" in r.text.lower() or "available after" in r.text.lower()
+    assert "Project Assignment" in r.text
+    assert "Save project" in r.text
+    assert "Routing Rationale" in r.text
+
+
+def test_recording_detail_project_assignment_trains_routing(tmp_path, monkeypatch):
+    cfg = _cfg(tmp_path)
+    monkeypatch.setattr(api, "_settings", cfg)
+    monkeypatch.setattr(ui_routes, "_settings", cfg)
+    init_db(cfg)
+    project = create_project("Roadmap", settings=cfg)
+    create_recording(
+        "rec-project-assign-1",
+        source="drive",
+        source_filename="roadmap-sync.mp3",
+        status=RECORDING_STATUS_READY,
+        settings=cfg,
+    )
+    profile = create_voice_profile("Alex", settings=cfg)
+    set_speaker_assignment(
+        recording_id="rec-project-assign-1",
+        diar_speaker_label="S1",
+        voice_profile_id=profile["id"],
+        confidence=1.0,
+        settings=cfg,
+    )
+    upsert_calendar_match(
+        recording_id="rec-project-assign-1",
+        candidates=[
+            {
+                "event_id": "evt-1",
+                "subject": "Roadmap weekly sync",
+                "organizer": "Alex",
+                "attendees": ["Priya"],
+                "score": 0.95,
+                "rationale": "manual-test",
+            }
+        ],
+        selected_event_id="evt-1",
+        selected_confidence=0.95,
+        settings=cfg,
+    )
+    derived = cfg.recordings_root / "rec-project-assign-1" / "derived"
+    derived.mkdir(parents=True, exist_ok=True)
+    (derived / "summary.json").write_text(
+        json.dumps(
+            {
+                "topic": "Roadmap status update",
+                "summary_bullets": ["Roadmap milestones reviewed"],
+                "decisions": ["Ship Q2 beta"],
+                "action_items": [{"task": "Finalize roadmap", "owner": "Alex"}],
+            }
+        ),
+        encoding="utf-8",
+    )
+
+    c = TestClient(api.app, follow_redirects=False)
+    resp = c.post(
+        "/ui/recordings/rec-project-assign-1/project",
+        data={
+            "project_id": str(project["id"]),
+            "train_routing": "1",
+        },
+    )
+    assert resp.status_code == 303
+    assert resp.headers["location"] == "/recordings/rec-project-assign-1?tab=project"
+
+    recording = get_recording("rec-project-assign-1", settings=cfg)
+    assert recording is not None
+    assert recording["project_id"] == project["id"]
+    assert count_routing_training_examples(project_id=project["id"], settings=cfg) == 1
+    keyword_rows = list_project_keyword_weights(project_id=project["id"], settings=cfg)
+    keywords = {row["keyword"] for row in keyword_rows}
+    assert "cal:roadmap" in keywords
+    assert "tag:roadmap" in keywords
+    assert f"voice:{profile['id']}" in keywords
+    assert recording["status"] in {RECORDING_STATUS_READY, RECORDING_STATUS_NEEDS_REVIEW}
 
 
 def test_recording_detail_speakers_tab_assignment_persists(tmp_path, monkeypatch):
diff --git a/lan_app/routing.py b/lan_app/routing.py
new file mode 100644
index 0000000..ca9a373
--- /dev/null
+++ b/lan_app/routing.py
@@ -0,0 +1,543 @@
+"""Project routing: suggest project with confidence and learn from corrections."""
+
+from __future__ import annotations
+
+from dataclasses import dataclass
+import json
+from pathlib import Path
+import re
+from typing import Any
+
+from .config import AppSettings
+from .constants import RECORDING_STATUS_NEEDS_REVIEW, RECORDING_STATUS_READY
+from .db import (
+    count_routing_training_examples,
+    create_routing_training_example,
+    get_calendar_match,
+    get_project,
+    get_recording,
+    increment_project_keyword_weights,
+    list_project_keyword_weights,
+    list_projects,
+    list_speaker_assignments,
+    set_recording_project,
+    set_recording_routing_suggestion,
+)
+
+_TOKEN_RE = re.compile(r"[A-Za-z0-9]+")
+_STOPWORDS = {
+    "a",
+    "an",
+    "and",
+    "at",
+    "for",
+    "from",
+    "in",
+    "is",
+    "of",
+    "on",
+    "or",
+    "the",
+    "to",
+    "with",
+}
+_SIGNAL_WEIGHTS = {
+    "calendar_subject": 0.40,
+    "participants": 0.15,
+    "llm_tags": 0.30,
+    "voice_profiles": 0.15,
+}
+_KEY_SCALE = 3.0
+
+
+@dataclass(frozen=True)
+class RoutingSignals:
+    calendar_subject_tokens: list[str]
+    participant_tokens: list[str]
+    llm_tags: list[str]
+    voice_profile_ids: list[int]
+
+
+def refresh_recording_routing(
+    recording_id: str,
+    *,
+    settings: AppSettings | None = None,
+    apply_workflow: bool = False,
+) -> dict[str, Any]:
+    cfg = settings or AppSettings()
+    recording = get_recording(recording_id, settings=cfg)
+    if recording is None:
+        raise KeyError(recording_id)
+
+    projects = list_projects(settings=cfg)
+    signals = _build_routing_signals(recording_id, settings=cfg)
+    threshold = float(cfg.routing_auto_select_threshold)
+
+    if not projects:
+        rationale = [
+            "No projects exist yet, so routing cannot suggest a project.",
+            "Create projects first to enable routing suggestions.",
+        ]
+        set_recording_routing_suggestion(
+            recording_id,
+            suggested_project_id=None,
+            routing_confidence=0.0,
+            routing_rationale=rationale,
+            settings=cfg,
+        )
+        return {
+            "recording_id": recording_id,
+            "suggested_project_id": None,
+            "suggested_project_name": None,
+            "confidence": 0.0,
+            "threshold": threshold,
+            "rationale": rationale,
+            "status_after_routing": recording.get("status"),
+            "auto_selected": False,
+            "training_examples_total": 0,
+        }
+
+    weight_rows = list_project_keyword_weights(settings=cfg)
+    weights_by_project: dict[int, dict[str, float]] = {}
+    for row in weight_rows:
+        try:
+            project_id = int(row.get("project_id"))
+            keyword = str(row.get("keyword") or "").strip()
+            weight = float(row.get("weight"))
+        except (TypeError, ValueError):
+            continue
+        if not keyword:
+            continue
+        weights_by_project.setdefault(project_id, {})[keyword] = weight
+
+    scored: list[dict[str, Any]] = []
+    for project in projects:
+        try:
+            project_id = int(project["id"])
+        except (TypeError, ValueError, KeyError):
+            continue
+        score_payload = _project_score(
+            project=project,
+            signals=signals,
+            learned_weights=weights_by_project.get(project_id, {}),
+        )
+        scored.append(
+            {
+                "project_id": project_id,
+                "project_name": str(project.get("name") or f"Project {project_id}"),
+                **score_payload,
+            }
+        )
+    scored.sort(key=lambda row: float(row.get("score") or 0.0), reverse=True)
+
+    top = scored[0] if scored else None
+    runner_up = scored[1] if len(scored) > 1 else None
+    top_score = float(top.get("score") or 0.0) if top else 0.0
+    runner_score = float(runner_up.get("score") or 0.0) if runner_up else 0.0
+    margin = max(0.0, top_score - runner_score)
+    confidence = min(1.0, max(0.0, (0.75 * top_score) + (0.25 * margin)))
+    if top is None or top_score <= 0.0:
+        suggested_project_id = None
+        suggested_project_name = None
+        confidence = 0.0
+    else:
+        suggested_project_id = int(top["project_id"])
+        suggested_project_name = str(top.get("project_name") or "")
+
+    rationale = _build_rationale(
+        top=top if suggested_project_id is not None else None,
+        runner_up=runner_up if suggested_project_id is not None else None,
+        confidence=confidence,
+        threshold=threshold,
+        signals=signals,
+    )
+
+    set_recording_routing_suggestion(
+        recording_id,
+        suggested_project_id=suggested_project_id,
+        routing_confidence=confidence,
+        routing_rationale=rationale,
+        settings=cfg,
+    )
+
+    auto_selected = False
+    status_after_routing: str = str(recording.get("status") or RECORDING_STATUS_READY)
+    if apply_workflow:
+        if suggested_project_id is not None and confidence >= threshold:
+            set_recording_project(
+                recording_id,
+                suggested_project_id,
+                settings=cfg,
+            )
+            auto_selected = True
+            status_after_routing = RECORDING_STATUS_READY
+        else:
+            status_after_routing = RECORDING_STATUS_NEEDS_REVIEW
+
+    return {
+        "recording_id": recording_id,
+        "suggested_project_id": suggested_project_id,
+        "suggested_project_name": suggested_project_name,
+        "confidence": round(confidence, 4),
+        "threshold": threshold,
+        "rationale": rationale,
+        "status_after_routing": status_after_routing,
+        "auto_selected": auto_selected,
+        "training_examples_total": count_routing_training_examples(settings=cfg),
+    }
+
+
+def train_routing_from_manual_selection(
+    recording_id: str,
+    project_id: int,
+    *,
+    settings: AppSettings | None = None,
+) -> dict[str, Any]:
+    cfg = settings or AppSettings()
+    recording = get_recording(recording_id, settings=cfg)
+    if recording is None:
+        raise KeyError(recording_id)
+    project = get_project(int(project_id), settings=cfg)
+    if project is None:
+        raise KeyError(project_id)
+
+    signals = _build_routing_signals(recording_id, settings=cfg)
+    example = create_routing_training_example(
+        recording_id=recording_id,
+        project_id=int(project_id),
+        calendar_subject_tokens=signals.calendar_subject_tokens,
+        tags=signals.llm_tags,
+        voice_profile_ids=signals.voice_profile_ids,
+        settings=cfg,
+    )
+
+    deltas: dict[str, float] = {}
+    for token in signals.calendar_subject_tokens:
+        deltas[f"cal:{token}"] = deltas.get(f"cal:{token}", 0.0) + 1.0
+    for token in signals.participant_tokens:
+        deltas[f"party:{token}"] = deltas.get(f"party:{token}", 0.0) + 0.6
+    for token in signals.llm_tags:
+        deltas[f"tag:{token}"] = deltas.get(f"tag:{token}", 0.0) + 0.8
+    for voice_profile_id in signals.voice_profile_ids:
+        key = f"voice:{voice_profile_id}"
+        deltas[key] = deltas.get(key, 0.0) + 1.2
+
+    updated_keywords = increment_project_keyword_weights(
+        project_id=int(project_id),
+        keyword_deltas=deltas,
+        settings=cfg,
+    )
+
+    return {
+        "recording_id": recording_id,
+        "project_id": int(project_id),
+        "training_example_id": example.get("id"),
+        "updated_keyword_count": updated_keywords,
+    }
+
+
+def _project_score(
+    *,
+    project: dict[str, Any],
+    signals: RoutingSignals,
+    learned_weights: dict[str, float],
+) -> dict[str, Any]:
+    project_name_tokens = _tokenize(str(project.get("name") or ""))
+
+    calendar_component = _component_score(
+        tokens=signals.calendar_subject_tokens,
+        keyword_prefix="cal",
+        learned_weights=learned_weights,
+        fallback_tokens=project_name_tokens,
+        fallback_score=0.4,
+    )
+    participant_component = _component_score(
+        tokens=signals.participant_tokens,
+        keyword_prefix="party",
+        learned_weights=learned_weights,
+        fallback_tokens=set(),
+        fallback_score=0.0,
+    )
+    llm_component = _component_score(
+        tokens=signals.llm_tags,
+        keyword_prefix="tag",
+        learned_weights=learned_weights,
+        fallback_tokens=project_name_tokens,
+        fallback_score=0.35,
+    )
+    voice_component = _component_score(
+        tokens=[str(value) for value in signals.voice_profile_ids],
+        keyword_prefix="voice",
+        learned_weights=learned_weights,
+        fallback_tokens=set(),
+        fallback_score=0.0,
+    )
+
+    component_rows = {
+        "calendar_subject": calendar_component,
+        "participants": participant_component,
+        "llm_tags": llm_component,
+        "voice_profiles": voice_component,
+    }
+    available_weight = 0.0
+    score_total = 0.0
+    for key, payload in component_rows.items():
+        if payload["token_count"] <= 0:
+            continue
+        weight = _SIGNAL_WEIGHTS[key]
+        available_weight += weight
+        score_total += weight * payload["score"]
+
+    if available_weight <= 0.0:
+        score = 0.0
+    else:
+        score = min(1.0, max(0.0, score_total / available_weight))
+
+    return {
+        "score": round(score, 4),
+        "components": component_rows,
+    }
+
+
+def _component_score(
+    *,
+    tokens: list[str],
+    keyword_prefix: str,
+    learned_weights: dict[str, float],
+    fallback_tokens: set[str],
+    fallback_score: float,
+) -> dict[str, Any]:
+    unique_tokens = sorted({token for token in tokens if token})
+    if not unique_tokens:
+        return {
+            "score": 0.0,
+            "token_count": 0,
+            "matched_count": 0,
+        }
+
+    signal_scores: list[float] = []
+    matched_count = 0
+    for token in unique_tokens:
+        lookup_key = f"{keyword_prefix}:{token}"
+        learned = float(learned_weights.get(lookup_key, 0.0))
+        if learned > 0.0:
+            contribution = min(learned / _KEY_SCALE, 1.0)
+            matched_count += 1
+        elif token in fallback_tokens:
+            contribution = fallback_score
+            if contribution > 0.0:
+                matched_count += 1
+        else:
+            contribution = 0.0
+        signal_scores.append(contribution)
+
+    score = sum(signal_scores) / float(len(signal_scores))
+    return {
+        "score": round(score, 4),
+        "token_count": len(unique_tokens),
+        "matched_count": matched_count,
+    }
+
+
+def _build_rationale(
+    *,
+    top: dict[str, Any] | None,
+    runner_up: dict[str, Any] | None,
+    confidence: float,
+    threshold: float,
+    signals: RoutingSignals,
+) -> list[str]:
+    if top is None:
+        return [
+            "No project could be scored from available routing signals.",
+            f"Confidence {confidence:.2f} is below threshold {threshold:.2f}; manual review required.",
+        ]
+
+    components = top.get("components", {})
+    calendar_component = components.get("calendar_subject", {})
+    participant_component = components.get("participants", {})
+    llm_component = components.get("llm_tags", {})
+    voice_component = components.get("voice_profiles", {})
+
+    rationale = [
+        (
+            f"Top project: {top.get('project_name')} "
+            f"(score={float(top.get('score') or 0.0):.2f})."
+        ),
+        (
+            "Calendar subject match "
+            f"{float(calendar_component.get('score') or 0.0):.2f} "
+            f"({int(calendar_component.get('matched_count') or 0)}/"
+            f"{int(calendar_component.get('token_count') or 0)} tokens)."
+        ),
+        (
+            "Organizer/attendee match "
+            f"{float(participant_component.get('score') or 0.0):.2f} "
+            f"({int(participant_component.get('matched_count') or 0)}/"
+            f"{int(participant_component.get('token_count') or 0)} tokens)."
+        ),
+        (
+            "LLM keyword match "
+            f"{float(llm_component.get('score') or 0.0):.2f} "
+            f"({int(llm_component.get('matched_count') or 0)}/"
+            f"{int(llm_component.get('token_count') or 0)} tags)."
+        ),
+        (
+            "Voice profile match "
+            f"{float(voice_component.get('score') or 0.0):.2f} "
+            f"({int(voice_component.get('matched_count') or 0)}/"
+            f"{int(voice_component.get('token_count') or 0)} profiles)."
+        ),
+    ]
+    if runner_up is not None:
+        rationale.append(
+            (
+                f"Runner-up: {runner_up.get('project_name')} "
+                f"(score={float(runner_up.get('score') or 0.0):.2f})."
+            )
+        )
+    rationale.append(
+        (
+            f"Final confidence {confidence:.2f} "
+            f"({'meets' if confidence >= threshold else 'below'} threshold {threshold:.2f})."
+        )
+    )
+    if not signals.calendar_subject_tokens:
+        rationale.append("No calendar subject tokens were available.")
+    if not signals.llm_tags:
+        rationale.append("No LLM tags/keywords were available yet.")
+    if not signals.voice_profile_ids:
+        rationale.append("No assigned voice profiles were available yet.")
+    return rationale
+
+
+def _build_routing_signals(
+    recording_id: str,
+    *,
+    settings: AppSettings,
+) -> RoutingSignals:
+    selected_calendar = _selected_calendar_candidate(recording_id, settings=settings)
+    subject_tokens = _tokenize(str(selected_calendar.get("subject") or ""))
+
+    participant_rows = [str(selected_calendar.get("organizer") or "").strip()]
+    attendee_rows = selected_calendar.get("attendees")
+    if isinstance(attendee_rows, list):
+        participant_rows.extend(str(row).strip() for row in attendee_rows)
+    participant_tokens: set[str] = set()
+    for row in participant_rows:
+        participant_tokens.update(_tokenize(row))
+
+    llm_tags = _llm_keywords(recording_id, settings=settings)
+
+    voice_profile_ids: set[int] = set()
+    for assignment in list_speaker_assignments(recording_id, settings=settings):
+        try:
+            profile_id_raw = assignment.get("voice_profile_id")
+            if profile_id_raw is None:
+                continue
+            voice_profile_ids.add(int(profile_id_raw))
+        except (TypeError, ValueError):
+            continue
+
+    return RoutingSignals(
+        calendar_subject_tokens=sorted(subject_tokens),
+        participant_tokens=sorted(participant_tokens),
+        llm_tags=sorted(llm_tags),
+        voice_profile_ids=sorted(voice_profile_ids),
+    )
+
+
+def _selected_calendar_candidate(
+    recording_id: str,
+    *,
+    settings: AppSettings,
+) -> dict[str, Any]:
+    row = get_calendar_match(recording_id, settings=settings) or {}
+    selected_event_id = str(row.get("selected_event_id") or "").strip()
+    if not selected_event_id:
+        return {}
+
+    candidates = row.get("candidates_json")
+    if not isinstance(candidates, list):
+        return {}
+    for candidate in candidates:
+        if not isinstance(candidate, dict):
+            continue
+        if str(candidate.get("event_id") or "").strip() == selected_event_id:
+            return candidate
+    return {}
+
+
+def _llm_keywords(recording_id: str, *, settings: AppSettings) -> set[str]:
+    summary_path = settings.recordings_root / recording_id / "derived" / "summary.json"
+    payload = _load_json_dict(summary_path)
+    snippets: list[str] = []
+    snippets.append(str(payload.get("topic") or ""))
+    snippets.extend(_text_list(payload.get("summary_bullets")))
+    snippets.extend(_text_list(payload.get("decisions")))
+    snippets.extend(_action_item_keywords(payload.get("action_items")))
+
+    tags: set[str] = set()
+    for snippet in snippets:
+        tags.update(_tokenize(snippet))
+    return tags
+
+
+def _action_item_keywords(value: Any) -> list[str]:
+    if not isinstance(value, list):
+        return []
+    out: list[str] = []
+    for row in value:
+        if not isinstance(row, dict):
+            continue
+        task = str(row.get("task") or "").strip()
+        owner = str(row.get("owner") or "").strip()
+        deadline = str(row.get("deadline") or "").strip()
+        if task:
+            out.append(task)
+        if owner:
+            out.append(owner)
+        if deadline:
+            out.append(deadline)
+    return out
+
+
+def _text_list(value: Any) -> list[str]:
+    if not isinstance(value, list):
+        return []
+    out: list[str] = []
+    for row in value:
+        text = str(row).strip()
+        if text:
+            out.append(text)
+    return out
+
+
+def _load_json_dict(path: Path) -> dict[str, Any]:
+    if not path.exists():
+        return {}
+    try:
+        payload = json.loads(path.read_text(encoding="utf-8"))
+    except (OSError, ValueError):
+        return {}
+    if not isinstance(payload, dict):
+        return {}
+    return payload
+
+
+def _tokenize(value: str) -> set[str]:
+    tokens: set[str] = set()
+    for raw_token in _TOKEN_RE.findall(value):
+        token = raw_token.lower()
+        if len(token) < 2:
+            continue
+        if token in _STOPWORDS:
+            continue
+        tokens.add(token)
+    return tokens
+
+
+__all__ = [
+    "refresh_recording_routing",
+    "train_routing_from_manual_selection",
+]
diff --git a/tests/test_routing.py b/tests/test_routing.py
new file mode 100644
index 0000000..9646047
--- /dev/null
+++ b/tests/test_routing.py
@@ -0,0 +1,188 @@
+from __future__ import annotations
+
+import json
+from pathlib import Path
+
+from lan_app.config import AppSettings
+from lan_app.constants import RECORDING_STATUS_NEEDS_REVIEW, RECORDING_STATUS_READY
+from lan_app.db import (
+    count_routing_training_examples,
+    create_project,
+    create_recording,
+    create_voice_profile,
+    get_recording,
+    increment_project_keyword_weights,
+    init_db,
+    list_project_keyword_weights,
+    set_speaker_assignment,
+    upsert_calendar_match,
+)
+from lan_app.routing import refresh_recording_routing, train_routing_from_manual_selection
+
+
+def _cfg(tmp_path: Path) -> AppSettings:
+    cfg = AppSettings(
+        data_root=tmp_path,
+        recordings_root=tmp_path / "recordings",
+        db_path=tmp_path / "db" / "app.db",
+    )
+    cfg.metrics_snapshot_path = tmp_path / "metrics.snap"
+    return cfg
+
+
+def _write_summary(cfg: AppSettings, recording_id: str, payload: dict[str, object]) -> None:
+    derived = cfg.recordings_root / recording_id / "derived"
+    derived.mkdir(parents=True, exist_ok=True)
+    (derived / "summary.json").write_text(json.dumps(payload), encoding="utf-8")
+
+
+def test_refresh_recording_routing_auto_selects_when_confident(tmp_path: Path):
+    cfg = _cfg(tmp_path)
+    cfg.routing_auto_select_threshold = 0.3
+    init_db(cfg)
+    roadmap = create_project("Roadmap", settings=cfg)
+    create_project("Budget", settings=cfg)
+    create_recording(
+        "rec-route-auto-1",
+        source="drive",
+        source_filename="roadmap-sync.mp3",
+        status=RECORDING_STATUS_READY,
+        settings=cfg,
+    )
+    upsert_calendar_match(
+        recording_id="rec-route-auto-1",
+        candidates=[
+            {
+                "event_id": "evt-roadmap",
+                "subject": "Roadmap sync",
+                "organizer": "Alex",
+                "attendees": ["Priya"],
+                "score": 0.95,
+                "rationale": "manual",
+            }
+        ],
+        selected_event_id="evt-roadmap",
+        selected_confidence=0.95,
+        settings=cfg,
+    )
+    _write_summary(
+        cfg,
+        "rec-route-auto-1",
+        {
+            "topic": "Roadmap planning",
+            "summary_bullets": ["Roadmap priorities and milestones"],
+        },
+    )
+    increment_project_keyword_weights(
+        project_id=roadmap["id"],
+        keyword_deltas={
+            "cal:roadmap": 3.0,
+            "tag:roadmap": 3.0,
+            "party:alex": 2.0,
+        },
+        settings=cfg,
+    )
+
+    decision = refresh_recording_routing(
+        "rec-route-auto-1",
+        settings=cfg,
+        apply_workflow=True,
+    )
+
+    assert decision["suggested_project_id"] == roadmap["id"]
+    assert decision["confidence"] >= cfg.routing_auto_select_threshold
+    assert decision["status_after_routing"] == RECORDING_STATUS_READY
+
+    recording = get_recording("rec-route-auto-1", settings=cfg)
+    assert recording is not None
+    assert recording["project_id"] == roadmap["id"]
+    assert recording["suggested_project_id"] == roadmap["id"]
+
+
+def test_refresh_recording_routing_marks_needs_review_when_low_confidence(tmp_path: Path):
+    cfg = _cfg(tmp_path)
+    init_db(cfg)
+    create_project("Roadmap", settings=cfg)
+    create_project("Budget", settings=cfg)
+    create_recording(
+        "rec-route-review-1",
+        source="drive",
+        source_filename="generic-meeting.mp3",
+        status=RECORDING_STATUS_READY,
+        settings=cfg,
+    )
+    _write_summary(
+        cfg,
+        "rec-route-review-1",
+        {"topic": "General discussion", "summary_bullets": ["Open items"]},
+    )
+
+    decision = refresh_recording_routing(
+        "rec-route-review-1",
+        settings=cfg,
+        apply_workflow=True,
+    )
+    assert decision["confidence"] < cfg.routing_auto_select_threshold
+    assert decision["status_after_routing"] == RECORDING_STATUS_NEEDS_REVIEW
+
+    recording = get_recording("rec-route-review-1", settings=cfg)
+    assert recording is not None
+    assert recording["project_id"] is None
+    assert recording["routing_confidence"] < cfg.routing_auto_select_threshold
+
+
+def test_train_routing_from_manual_selection_persists_weights(tmp_path: Path):
+    cfg = _cfg(tmp_path)
+    init_db(cfg)
+    project = create_project("Roadmap", settings=cfg)
+    create_recording(
+        "rec-route-train-1",
+        source="drive",
+        source_filename="roadmap-train.mp3",
+        status=RECORDING_STATUS_READY,
+        settings=cfg,
+    )
+    upsert_calendar_match(
+        recording_id="rec-route-train-1",
+        candidates=[
+            {
+                "event_id": "evt-1",
+                "subject": "Roadmap training session",
+                "organizer": "Alex",
+                "attendees": ["Priya"],
+                "score": 0.9,
+                "rationale": "manual",
+            }
+        ],
+        selected_event_id="evt-1",
+        selected_confidence=0.9,
+        settings=cfg,
+    )
+    _write_summary(
+        cfg,
+        "rec-route-train-1",
+        {"topic": "Roadmap training", "summary_bullets": ["Roadmap delivery plan"]},
+    )
+    profile = create_voice_profile("Alex", settings=cfg)
+    set_speaker_assignment(
+        recording_id="rec-route-train-1",
+        diar_speaker_label="S1",
+        voice_profile_id=profile["id"],
+        confidence=1.0,
+        settings=cfg,
+    )
+
+    out = train_routing_from_manual_selection(
+        "rec-route-train-1",
+        project["id"],
+        settings=cfg,
+    )
+
+    assert out["project_id"] == project["id"]
+    assert out["training_example_id"] is not None
+    assert count_routing_training_examples(project_id=project["id"], settings=cfg) == 1
+    weights = list_project_keyword_weights(project_id=project["id"], settings=cfg)
+    keywords = {row["keyword"] for row in weights}
+    assert "cal:roadmap" in keywords
+    assert "tag:roadmap" in keywords
+    assert f"voice:{profile['id']}" in keywords
