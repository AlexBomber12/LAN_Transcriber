diff --git a/lan_app/db.py b/lan_app/db.py
index 2d2c826..9cbbe8f 100644
--- a/lan_app/db.py
+++ b/lan_app/db.py
@@ -757,7 +757,6 @@ def list_stale_started_jobs(
             FROM jobs AS j
             JOIN recordings AS r ON r.id = j.recording_id
             WHERE j.status = ?
-              AND r.status = ?
               AND j.started_at IS NOT NULL
               AND j.started_at < ?
             ORDER BY j.started_at ASC, j.created_at ASC
@@ -765,7 +764,6 @@ def list_stale_started_jobs(
             """,
             (
                 JOB_STATUS_STARTED,
-                RECORDING_STATUS_PROCESSING,
                 before_started_at,
                 safe_limit,
             ),
diff --git a/lan_app/reaper.py b/lan_app/reaper.py
index eb6cfb8..d94a76e 100644
--- a/lan_app/reaper.py
+++ b/lan_app/reaper.py
@@ -5,7 +5,12 @@ from pathlib import Path
 from typing import Any
 
 from .config import AppSettings
-from .constants import DEFAULT_REQUEUE_JOB_TYPE, RECORDING_STATUS_NEEDS_REVIEW
+from .constants import (
+    DEFAULT_REQUEUE_JOB_TYPE,
+    RECORDING_STATUS_NEEDS_REVIEW,
+    RECORDING_STATUS_PROCESSING,
+    RECORDING_STATUS_QUEUED,
+)
 from .db import (
     fail_job_if_queued,
     fail_job_if_started,
@@ -15,6 +20,11 @@ from .db import (
 )
 
 _RECOVERY_ERROR = "stuck job recovered"
+_STALE_DOWNGRADE_STATUSES = {
+    RECORDING_STATUS_QUEUED,
+    RECORDING_STATUS_PROCESSING,
+    RECORDING_STATUS_NEEDS_REVIEW,
+}
 
 
 def _utc_now() -> datetime:
@@ -57,20 +67,26 @@ def run_stuck_job_reaper_once(
     for row in stale_rows:
         job_id = str(row.get("id") or "").strip()
         recording_id = str(row.get("recording_id") or "").strip()
+        recording_status = str(row.get("recording_status") or "").strip()
         job_type = str(row.get("type") or "").strip() or DEFAULT_REQUEUE_JOB_TYPE
         if not job_id or not recording_id:
             continue
         if not fail_job_if_started(job_id, _RECOVERY_ERROR, settings=cfg):
             # Job completed or moved to another state after selection.
             continue
-        set_recording_status(recording_id, RECORDING_STATUS_NEEDS_REVIEW, settings=cfg)
+        if recording_status in _STALE_DOWNGRADE_STATUSES:
+            set_recording_status(
+                recording_id,
+                RECORDING_STATUS_NEEDS_REVIEW,
+                settings=cfg,
+            )
+            recovered_recording_ids.add(recording_id)
         _append_step_log(
             _step_log_path(recording_id, job_type, cfg),
             f"stuck job recovery applied job={job_id}",
             now=current_time,
         )
         recovered_job_ids.append(job_id)
-        recovered_recording_ids.add(recording_id)
 
     processing_rows = list_processing_recordings_without_started_job(
         settings=cfg,
diff --git a/tests/test_reaper.py b/tests/test_reaper.py
index b9e3f0d..f5034c1 100644
--- a/tests/test_reaper.py
+++ b/tests/test_reaper.py
@@ -11,6 +11,8 @@ from lan_app.constants import (
     JOB_TYPE_PRECHECK,
     RECORDING_STATUS_NEEDS_REVIEW,
     RECORDING_STATUS_PROCESSING,
+    RECORDING_STATUS_QUEUED,
+    RECORDING_STATUS_READY,
 )
 from lan_app.db import connect, create_job, create_recording, get_job, get_recording, init_db
 from lan_app.reaper import run_stuck_job_reaper_once
@@ -126,6 +128,108 @@ def test_reaper_skips_stale_started_job_when_it_already_transitioned(
     assert recording["status"] == RECORDING_STATUS_PROCESSING
 
 
+def test_reaper_recovers_stale_started_job_when_recording_status_is_queued(
+    tmp_path: Path,
+):
+    cfg = _test_settings(tmp_path)
+    init_db(cfg)
+    create_recording(
+        "rec-reaper-stale-queued-1",
+        source="test",
+        source_filename="stale-queued.wav",
+        status=RECORDING_STATUS_QUEUED,
+        settings=cfg,
+    )
+    create_job(
+        "job-reaper-stale-queued-1",
+        recording_id="rec-reaper-stale-queued-1",
+        job_type=JOB_TYPE_PRECHECK,
+        status=JOB_STATUS_STARTED,
+        settings=cfg,
+        attempt=1,
+    )
+    with connect(cfg) as conn:
+        conn.execute(
+            """
+            UPDATE jobs
+            SET started_at = ?, updated_at = ?
+            WHERE id = ?
+            """,
+            (
+                "2026-02-22T00:00:00Z",
+                "2026-02-22T00:00:00Z",
+                "job-reaper-stale-queued-1",
+            ),
+        )
+        conn.commit()
+
+    summary = run_stuck_job_reaper_once(
+        settings=cfg,
+        now=datetime(2026, 2, 23, 0, 0, 0, tzinfo=timezone.utc),
+    )
+
+    job = get_job("job-reaper-stale-queued-1", settings=cfg)
+    recording = get_recording("rec-reaper-stale-queued-1", settings=cfg)
+    assert job is not None
+    assert recording is not None
+    assert summary["stale_started_jobs"] == 1
+    assert summary["recovered_jobs"] == 1
+    assert summary["recovered_recordings"] == 1
+    assert job["status"] == JOB_STATUS_FAILED
+    assert recording["status"] == RECORDING_STATUS_NEEDS_REVIEW
+
+
+def test_reaper_does_not_downgrade_ready_recording_when_clearing_stale_started_job(
+    tmp_path: Path,
+):
+    cfg = _test_settings(tmp_path)
+    init_db(cfg)
+    create_recording(
+        "rec-reaper-stale-ready-1",
+        source="test",
+        source_filename="stale-ready.wav",
+        status=RECORDING_STATUS_READY,
+        settings=cfg,
+    )
+    create_job(
+        "job-reaper-stale-ready-1",
+        recording_id="rec-reaper-stale-ready-1",
+        job_type=JOB_TYPE_PRECHECK,
+        status=JOB_STATUS_STARTED,
+        settings=cfg,
+        attempt=1,
+    )
+    with connect(cfg) as conn:
+        conn.execute(
+            """
+            UPDATE jobs
+            SET started_at = ?, updated_at = ?
+            WHERE id = ?
+            """,
+            (
+                "2026-02-22T00:00:00Z",
+                "2026-02-22T00:00:00Z",
+                "job-reaper-stale-ready-1",
+            ),
+        )
+        conn.commit()
+
+    summary = run_stuck_job_reaper_once(
+        settings=cfg,
+        now=datetime(2026, 2, 23, 0, 0, 0, tzinfo=timezone.utc),
+    )
+
+    job = get_job("job-reaper-stale-ready-1", settings=cfg)
+    recording = get_recording("rec-reaper-stale-ready-1", settings=cfg)
+    assert job is not None
+    assert recording is not None
+    assert summary["stale_started_jobs"] == 1
+    assert summary["recovered_jobs"] == 1
+    assert summary["recovered_recordings"] == 0
+    assert job["status"] == JOB_STATUS_FAILED
+    assert recording["status"] == RECORDING_STATUS_READY
+
+
 def test_reaper_recovers_processing_recording_without_started_job(tmp_path: Path):
     cfg = _test_settings(tmp_path)
     init_db(cfg)
