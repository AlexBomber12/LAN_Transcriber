diff --git a/lan_app/db.py b/lan_app/db.py
index 7335589..744d21a 100644
--- a/lan_app/db.py
+++ b/lan_app/db.py
@@ -28,6 +28,7 @@ def _quoted(values: tuple[str, ...]) -> str:
 _RECORDING_STATUSES_SQL = _quoted(RECORDING_STATUSES)
 _JOB_STATUSES_SQL = _quoted(JOB_STATUSES)
 _JOB_TYPES_SQL = _quoted(JOB_TYPES)
+_PROJECT_ASSIGNMENT_SOURCES = {"manual", "auto"}
 
 _MIGRATIONS: tuple[str, ...] = (
     f"""
@@ -219,6 +220,13 @@ _MIGRATIONS: tuple[str, ...] = (
     CREATE INDEX IF NOT EXISTS idx_routing_project_keyword_weights_project_id
         ON routing_project_keyword_weights(project_id);
     """,
+    """
+    ALTER TABLE recordings ADD COLUMN project_assignment_source TEXT;
+
+    UPDATE recordings
+    SET project_assignment_source = 'manual'
+    WHERE project_id IS NOT NULL AND project_assignment_source IS NULL;
+    """,
 )
 
 _UNSET = object()
@@ -270,6 +278,18 @@ def _validate_job_type(job_type: str) -> None:
         raise ValueError(f"Unsupported job type: {job_type}")
 
 
+def _normalise_project_assignment_source(source: str | None) -> str | None:
+    if source is None:
+        return None
+    value = str(source).strip().lower()
+    if not value:
+        return None
+    if value not in _PROJECT_ASSIGNMENT_SOURCES:
+        options = ", ".join(sorted(_PROJECT_ASSIGNMENT_SOURCES))
+        raise ValueError(f"Unsupported project assignment source: {value} ({options})")
+    return value
+
+
 def _normalise_keyword(value: object) -> str:
     return " ".join(str(value).strip().lower().split())
 
@@ -316,6 +336,7 @@ def create_recording(
     language_override: str | None = None,
     target_summary_language: str | None = None,
     project_id: int | None = None,
+    project_assignment_source: str | None = None,
     onenote_page_id: str | None = None,
     drive_file_id: str | None = None,
     drive_md5: str | None = None,
@@ -324,15 +345,23 @@ def create_recording(
     _validate_recording_status(status)
     now = _utc_now()
     captured = captured_at or now
+    resolved_assignment_source = _normalise_project_assignment_source(
+        project_assignment_source
+    )
+    if project_id is None:
+        resolved_assignment_source = None
+    elif resolved_assignment_source is None:
+        resolved_assignment_source = "manual"
     with connect(settings) as conn:
         conn.execute(
             """
             INSERT INTO recordings (
                 id, source, source_filename, captured_at, duration_sec, status,
                 quarantine_reason, language_auto, language_override, target_summary_language, project_id,
+                project_assignment_source,
                 onenote_page_id, drive_file_id, drive_md5, created_at, updated_at
             )
-            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
+            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
             """,
             (
                 recording_id,
@@ -346,6 +375,7 @@ def create_recording(
                 language_override,
                 target_summary_language,
                 project_id,
+                resolved_assignment_source,
                 onenote_page_id,
                 drive_file_id,
                 drive_md5,
@@ -446,18 +476,29 @@ def set_recording_project(
     project_id: int | None,
     *,
     settings: AppSettings | None = None,
+    assignment_source: str | None = None,
 ) -> bool:
     init_db(settings)
     now = _utc_now()
     resolved_project_id = None if project_id is None else int(project_id)
+    resolved_assignment_source = _normalise_project_assignment_source(assignment_source)
+    if resolved_project_id is None:
+        resolved_assignment_source = None
+    elif resolved_assignment_source is None:
+        resolved_assignment_source = "manual"
     with connect(settings) as conn:
         updated = conn.execute(
             """
             UPDATE recordings
-            SET project_id = ?, updated_at = ?
+            SET project_id = ?, project_assignment_source = ?, updated_at = ?
             WHERE id = ?
             """,
-            (resolved_project_id, now, recording_id),
+            (
+                resolved_project_id,
+                resolved_assignment_source,
+                now,
+                recording_id,
+            ),
         )
         conn.commit()
     return updated.rowcount > 0
@@ -818,14 +859,19 @@ def delete_project(
 ) -> bool:
     init_db(settings)
     target_project_id = int(project_id)
+    now = _utc_now()
     with connect(settings) as conn:
         conn.execute(
             """
             UPDATE recordings
-            SET suggested_project_id = NULL
+            SET
+                suggested_project_id = NULL,
+                routing_confidence = NULL,
+                routing_rationale_json = '[]',
+                updated_at = ?
             WHERE suggested_project_id = ?
             """,
-            (target_project_id,),
+            (now, target_project_id),
         )
         deleted = conn.execute("DELETE FROM projects WHERE id = ?", (target_project_id,))
         conn.commit()
diff --git a/lan_app/routing.py b/lan_app/routing.py
index e4ea537..ef32f8d 100644
--- a/lan_app/routing.py
+++ b/lan_app/routing.py
@@ -68,6 +68,10 @@ def refresh_recording_routing(
     recording = get_recording(recording_id, settings=cfg)
     if recording is None:
         raise KeyError(recording_id)
+    current_project_id = recording.get("project_id")
+    current_assignment_source = str(
+        recording.get("project_assignment_source") or ""
+    ).strip().lower()
 
     projects = list_projects(settings=cfg)
     signals = _build_routing_signals(recording_id, settings=cfg)
@@ -170,15 +174,17 @@ def refresh_recording_routing(
                 recording_id,
                 suggested_project_id,
                 settings=cfg,
+                assignment_source="auto",
             )
             auto_selected = True
             status_after_routing = RECORDING_STATUS_READY
         else:
-            set_recording_project(
-                recording_id,
-                None,
-                settings=cfg,
-            )
+            if current_project_id is not None and current_assignment_source == "auto":
+                set_recording_project(
+                    recording_id,
+                    None,
+                    settings=cfg,
+                )
             status_after_routing = RECORDING_STATUS_NEEDS_REVIEW
 
     return {
diff --git a/tests/test_routing.py b/tests/test_routing.py
index c8d6128..762227b 100644
--- a/tests/test_routing.py
+++ b/tests/test_routing.py
@@ -130,10 +130,54 @@ def test_refresh_recording_routing_marks_needs_review_when_low_confidence(tmp_pa
 
     recording = get_recording("rec-route-review-1", settings=cfg)
     assert recording is not None
-    assert recording["project_id"] is None
+    assert recording["project_id"] == roadmap["id"]
+    assert recording["project_assignment_source"] == "manual"
     assert recording["routing_confidence"] < cfg.routing_auto_select_threshold
 
 
+def test_refresh_recording_routing_clears_auto_assignment_when_low_confidence(
+    tmp_path: Path,
+):
+    cfg = _cfg(tmp_path)
+    init_db(cfg)
+    roadmap = create_project("Roadmap", settings=cfg)
+    create_project("Budget", settings=cfg)
+    create_recording(
+        "rec-route-auto-clear-1",
+        source="drive",
+        source_filename="generic-meeting.mp3",
+        status=RECORDING_STATUS_READY,
+        project_id=roadmap["id"],
+        project_assignment_source="auto",
+        settings=cfg,
+    )
+    set_recording_routing_suggestion(
+        "rec-route-auto-clear-1",
+        suggested_project_id=roadmap["id"],
+        routing_confidence=0.95,
+        routing_rationale=["Auto-selected previously"],
+        settings=cfg,
+    )
+    _write_summary(
+        cfg,
+        "rec-route-auto-clear-1",
+        {"topic": "General discussion", "summary_bullets": ["Open items"]},
+    )
+
+    decision = refresh_recording_routing(
+        "rec-route-auto-clear-1",
+        settings=cfg,
+        apply_workflow=True,
+    )
+    assert decision["confidence"] < cfg.routing_auto_select_threshold
+    assert decision["status_after_routing"] == RECORDING_STATUS_NEEDS_REVIEW
+
+    recording = get_recording("rec-route-auto-clear-1", settings=cfg)
+    assert recording is not None
+    assert recording["project_id"] is None
+    assert recording["project_assignment_source"] is None
+
+
 def test_refresh_recording_routing_without_projects_forces_needs_review(tmp_path: Path):
     cfg = _cfg(tmp_path)
     init_db(cfg)
@@ -182,6 +226,8 @@ def test_delete_project_clears_recording_suggested_project_id(tmp_path: Path):
     after = get_recording("rec-route-cleanup-1", settings=cfg)
     assert after is not None
     assert after["suggested_project_id"] is None
+    assert after["routing_confidence"] is None
+    assert after["routing_rationale_json"] == []
 
 
 def test_train_routing_from_manual_selection_persists_weights(tmp_path: Path):
